<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>月間シフト管理</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ja.js"></script>
    <!-- <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #f0f2f5; font-size: 12px; }
        .container { padding: 10px 15px; }
        .header-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;}
        .month-header { display: flex; justify-content: center; align-items: center; gap: 15px; text-align: center; color: #343a40; }
        h1#month-display { font-size: 22px; font-weight: bold; margin: 0; }
        .month-header button { font-size: 22px; background: none; border: none; cursor: pointer; }

        .header-actions { display: flex; align-items: center; gap: 10px; }
        #manageStaffBtn, #showHistoryBtn, #saveChangesBtn, #changeNotificationBtn, #checklistBtn { background: #007bff; color: white; border: none; padding: 7px 12px; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 12px; }
        #saveChangesBtn { background: #28a745; }
        #changeNotificationBtn { background: #ff6b6b; }
        #checklistBtn { background: #17a2b8; }

        .controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        #create-magnet-btn { background: #17a2b8; color: white; border: none; padding: 7px 12px; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 12px; }
        #unassigned-box { border: 1px dashed #ccc; padding: 5px; min-height: 30px; background: #f8f9fa; border-radius: 6px; flex-grow: 1; margin-left: 15px; display: flex; align-items: center; gap: 10px;}
        #unassigned-box h4 { margin: 0; text-align: center; color: #6c757d; font-size: 12px; flex-shrink: 0; }

        #shift-table-container {
            width: 100%;
            overflow: auto;
            max-height: calc(100vh - 150px);
        }

        table { width: 100%; min-width: 1200px; border-collapse: collapse; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ccc; padding: 4px; text-align: center; vertical-align: top; }

        th {
            background: #343a40;
            color: white;
            position: sticky;
            z-index: 10;
            min-width: 150px;
        }

        thead tr:first-child th {
            top: 0;
            font-size: 18px;
            height: 40px;
        }
        thead tr:nth-child(2) th {
            top: 40px;
            background: #495057;
            height: 45px;
        }
        .leave-info-cell {
            text-align: left;
            font-size: 12px;
            font-weight: normal;
            vertical-align: top;
            padding: 5px;
        }
        .leave-info-cell .leave-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        .leave-info-cell .leave-left {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .leave-info-cell .leave-right {
            text-align: right;
        }
        .leave-input {
            width: 45px;
            padding: 0;
            border: 1px solid #999;
            border-radius: 3px;
            text-align: center;
            font-size: 11px;
            height: 20px;
            background-color: #f0f0f0;
            cursor: not-allowed;
        }

        /* 保管場所列のスタイル（1列目） */
        th:first-child, td:first-child {
            min-width: 80px !important;
            max-width: 80px !important;
            width: 80px !important;
            font-weight: bold;
            position: sticky;
            left: 0 !important;
            z-index: 11;
        }

        thead th:first-child {
            background: #343a40 !important;
            color: white;
        }

        tbody td:first-child {
            background: #f8f9fa !important;
        }

        /* 日付列のスタイル（2列目） */
        th:nth-child(2), td:nth-child(2) {
            min-width: 70px !important;
            max-width: 70px !important;
            width: 70px !important;
            font-weight: bold;
            position: sticky;
            left: 80px !important;
            z-index: 11;
            background: white;
            vertical-align: middle;
            font-size: 16px;
        }

        thead th:nth-child(2) {
            background: #343a40 !important;
            color: white;
        }

        tbody td:nth-child(2) {
            background: white !important;
        }

        .storage-location {
            background-color: #f0f2f5;
        }
        .storage-location .magnet {
            background-color: #e9ecef;
        }
        .storage-location .magnet .magnet-user {
            color: #495057;
        }


        tbody td { height: 550px; overflow-y: auto; overflow-x: visible; position: relative; padding-bottom: 25px; }

        .time-summary {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            background-color: #f8f9fa;
            border-top: 1px solid #ccc;
            padding: 3px 2px;
            font-size: 10px;
            font-weight: bold;
            height: 20px;
            align-items: center;
        }
        .time-summary span {
            text-align: center;
            flex: 1;
        }

        tr[data-day="6"] td:nth-child(2) { background-color: #a3c9f0; }
        tr[data-day="0"] td:nth-child(2) { background-color: #f2b3bf; }

        /* 週合計行のスタイル */
        tr.week-summary-row {
            background-color: #fff3cd;
            font-weight: bold;
        }
        tr.week-summary-row td {
            background-color: #fff3cd !important;
            border-top: 2px solid #ff6b6b;
            border-bottom: 2px solid #ff6b6b;
            font-size: 10px;
            padding: 2px 4px;
            vertical-align: middle;
            line-height: 1.2;
        }
        tr.week-summary-row td:first-child {
            text-align: center;
        }

        tfoot td { font-weight: bold; background: #f8f9fa; }
        .magnet {
            font-size: 11px;
            line-height: 1.3;
            padding: 3px 5px;
            border-radius: 3px;
            margin: 2px;
            border: 1px solid rgba(0,0,0,0.2);
            cursor: grab;
            background-color: #ffffff;
            display: grid !important;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            width: 220px !important;
            min-width: 220px !important;
            max-width: 220px !important;
            vertical-align: top;
            box-sizing: border-box !important;
            position: relative;
        }
        .magnet.dragging { opacity: 0.5; }
        .drop-zone.drag-over { background-color: #e9ecef; }

        .magnet-left {
            display: flex;
            align-items: center;
            gap: 4px;
            overflow: hidden;
            flex-wrap: wrap;
        }

        .magnet-right {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .magnet-name {
            font-weight: bold;
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .magnet-service {
            font-size: 10px;
            color: #666;
            flex-shrink: 0;
        }

        .magnet-star {
            font-size: 12px;
            color: #ffc107;
            flex-shrink: 0;
        }

        .magnet-time {
            font-size: 14px !important;
            font-weight: bold;
            white-space: nowrap;
        }

        .magnet.highlight {
            background-color: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 5px 1px #ffc107;
            transition: background-color 0.3s ease;
        }
        .magnet.cut {
            cursor: grabbing;
            opacity: 0.5;
            border: 2px dashed #007bff;
        }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center;
            align-items: center; z-index: 2000;
        }
        .modal-overlay.visible { display: flex; }
        .modal-content {
            background: #f0f2f5; width: 90%; max-width: 500px;
            padding: 15px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-bottom: 15px; }
        .modal-header h2 { font-size: 18px; margin: 0; }
        .modal-close-btn { font-size: 24px; border: none; background: none; cursor: pointer; }
        .modal-form-group { margin-bottom: 10px; }
        .modal-form-group label { display: block; font-size: 12px; color: #666; margin-bottom: 4px; }
        .modal-form-group input, .modal-form-group textarea, .modal-form-group select {
            width: 100%; box-sizing: border-box; padding: 8px; border-radius: 6px;
            border: 1px solid #ccc; font-size: 14px; background-color: #fff;
        }
        .modal-form-group .time-inputs { display: flex; align-items: center; gap: 5px; }
        .modal-form-group .time-inputs input { text-align: center; }
        .modal-form-group textarea { min-height: 70px; resize: vertical; }
        .modal-form-group input:read-only, .modal-form-group textarea:read-only {
            background-color: #e9ecef; color: #495057; border-color: #ced4da;
        }
        .modal-footer { margin-top: 20px; display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; }
        .modal-footer button {
            background-color: #fff; border: 1px solid #ccc; border-radius: 6px;
            padding: 8px 12px; cursor: pointer; font-size: 12px;
        }

        #staff-list-editor {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: white;
        }
        #staff-list-editor li {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: grab;
            background-color: white;
            gap: 10px;
        }
        #staff-list-editor li:last-child {
            border-bottom: none;
        }
        #staff-list-editor li.dragging {
            opacity: 0.5;
            background: #eaf4ff;
        }
        .staff-name {
            flex-grow: 1;
        }
        .staff-type, .staff-gender {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            background: #e0e0e0;
        }
        .add-staff-container {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .add-staff-container select {
            flex: 1;
            min-width: 100px;
        }
        .delete-staff-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 10px;
        }
        .add-staff-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        #new-staff-name-input {
            flex-grow: 1;
        }
        #add-new-staff-btn {
            background-color: #28a745;
            color: white;
        }

        #history-list {
            list-style: none;
            padding: 10px;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
        }
        #history-list li {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        #history-list li:last-child {
            border-bottom: none;
        }
        .history-meta {
            color: #6c757d;
            font-size: 11px;
            display: block;
        }

        /* コンテキストメニュー */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            min-width: 120px;
            display: none;
        }
        .context-menu.visible {
            display: block;
        }
        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        .context-menu-item:hover {
            background: #f0f0f0;
        }
        .context-menu-item:first-child {
            border-radius: 8px 8px 0 0;
        }
        .context-menu-item:last-child {
            border-radius: 0 0 8px 8px;
        }
        .context-menu-item.delete {
            color: #dc3545;
            font-weight: 600;
        }
        .context-menu-item.delete:hover {
            background: #fee;
        }

        /* マグネットの色分け */
        .magnet.color-yellow {
            background-color: #fff59d !important; /* 黄色 - 同行 */
        }
        .magnet.color-red {
            background-color: #f8f9fa !important; /* 白背景を維持 */
            border-left: 4px solid #c62828;
        }
        .magnet.color-red .magnet-user,
        .magnet.color-red .magnet-content {
            color: #c62828 !important; /* 文字色のみ赤 */
        }
        .magnet.color-orange {
            background-color: #ffcc80 !important; /* オレンジ色 - 時間変更 */
        }
        .magnet.color-blue {
            background-color: #90caf9 !important; /* 青色 - 利用者名未入力 */
        }

        /* 会社負担マグネット - 他の色よりも優先されるよう最後に定義 */
        .magnet.company-burden,
        td.drop-zone > .magnet.company-burden,
        .storage-location .magnet.company-burden,
        #unassigned-box .magnet.company-burden {
            background-color: #9370db !important; /* 紫色 */
            background: #9370db !important;
            color: white !important;
        }
        .magnet.company-burden .magnet-user,
        .magnet.company-burden .magnet-content,
        td.drop-zone > .magnet.company-burden .magnet-user,
        td.drop-zone > .magnet.company-burden .magnet-content {
            color: white !important;
        }

        /* 新規作成マグネットと日付変更マグネットのマーカー - テキストのみ表示 */
        /* CSSではなくHTMLに直接マーカーを追加する方式に変更したため、このCSSは不要 */

        /* セルの背景色（公休・有給） */
        td.cell-koukyu {
            background-color: #c8e6c9 !important;
            position: relative;
        }
        td.cell-yuukyu {
            background-color: #ffe0b2 !important;
            position: relative;
        }
        td.cell-tokkyu {
            background-color: #e3f2fd !important;
            position: relative;
        }
        td.cell-koukyu::before {
            content: '公休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #2e7d32;
            pointer-events: none;
            z-index: 0;
        }
        td.cell-yuukyu::before {
            content: '有休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #e65100;
            pointer-events: none;
            z-index: 0;
        }
        td.cell-tokkyu::before {
            content: '特休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #1565c0;
            pointer-events: none;
            z-index: 0;
        }
        td.drop-zone > .magnet {
            position: relative;
            z-index: 1;
        }

    </style> -->
    <style>
        /* セルの背景色と文字表示（公休・有休・特休） */
        td.cell-koukyu {
            background-color: #c8e6c9 !important;
            position: relative;
        }

        td.cell-yuukyu {
            background-color: #ffe0b2 !important;
            position: relative;
        }

        td.cell-tokkyu {
            background-color: #e3f2fd !important;
            position: relative;
        }

        td.cell-koukyu::before {
            content: '公休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #2e7d32;
            pointer-events: none;
            z-index: 0;
        }

        td.cell-yuukyu::before {
            content: '有休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #e65100;
            pointer-events: none;
            z-index: 0;
        }

        td.cell-tokkyu::before {
            content: '特休';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 14px;
            color: #1565c0;
            pointer-events: none;
            z-index: 0;
        }

        td.drop-zone>.magnet {
            position: relative;
            z-index: 1;
        }

        /* メニュー開閉ボタン */
        .menu-toggle-btn {
            position: fixed;
            top: 70px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ffb380 0%, #ff9d66 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 1002;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(255, 140, 80, 0.3);
            transition: all 0.3s ease;
        }

        .menu-toggle-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(255, 140, 80, 0.4);
        }

        .menu-toggle-btn::before {
            content: '☰';
            color: white;
            font-size: 20px;
            font-weight: bold;
        }

        body.menu-visible .menu-toggle-btn {
            left: 260px;
        }

        body.menu-visible .menu-toggle-btn::before {
            content: '✕';
            font-size: 18px;
        }

        /* containerの調整 - メニューボタンと重ならないように */
        .container {
            padding-top: 10px;
        }

        .navbar-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 250px;
            height: 100vh;
            background: white;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
            z-index: 1001;
            overflow-y: auto;
            transform: translateX(0);
        }

        .navbar-menu.hidden {
            transform: translateX(-100%);
        }

        .navbar-menu-header {
            background: linear-gradient(135deg, #ffb380 0%, #ff9d66 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .navbar-menu-title {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        .navbar-menu-close {
            background: none;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
        }

        .navbar-menu-items {
            padding: 20px 0;
        }

        .navbar-menu-item {
            display: block;
            padding: 15px 30px;
            color: #333;
            text-decoration: none;
            font-size: 16px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .navbar-menu-item:hover {
            background: #ffe8d6;
            border-left-color: #ff9d66;
            color: #ff9d66;
        }

        .navbar-menu-item.active {
            background: #fff3e6;
            border-left-color: #ffb380;
            color: #ffb380;
            font-weight: 600;
        }

        /* コンテンツエリアの調整 */
        body {
            transition: margin-left 0.3s ease;
        }

        body.menu-visible {
            margin-left: 250px;
        }

        body.menu-visible .container {
            width: calc(100% - 250px);
        }

        @media (max-width: 768px) {
            .navbar-container {
                padding: 12px 15px;
            }

            .navbar-brand {
                font-size: 18px;
            }

            body.menu-visible {
                margin-left: 200px;
            }

            .navbar-menu {
                width: 200px;
            }
        }
    </style>
</head>

<body>
    <!-- ローディングインジケータ -->
    <div id="loading-indicator"
        style="display: none; position: fixed; top: 60px; right: 20px; background: rgba(0, 123, 255, 0.9); color: white; padding: 12px 20px; border-radius: 8px; z-index: 9999; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: fadeIn 0.3s; min-width: 200px;">
        <div style="display: flex; align-items: center; margin-bottom: 8px;">
            <span style="display: inline-block; margin-right: 8px; animation: spin 1s linear infinite;">⏳</span>
            <span>データ読み込み中...</span>
        </div>
        <div
            style="background: rgba(255,255,255,0.2); border-radius: 10px; overflow: hidden; height: 6px; margin-bottom: 4px;">
            <div id="loading-progress-bar" style="background: white; height: 100%; width: 0%; transition: width 0.3s;">
            </div>
        </div>
        <div style="text-align: right; font-size: 12px;">
            <span id="loading-progress-text">0%</span>
        </div>
    </div>
    <style>
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>

    <!-- メニュー開閉ボタン -->
    <button class="menu-toggle-btn" id="menuToggle" title="メニューを開く/閉じる"></button>

    <!-- サイドメニュー -->
    <div class="navbar-menu" id="navbarMenu">
        <div class="navbar-menu-header">
            <span class="navbar-menu-title">メニュー</span>
            <a href="権限設定/index.html" class="settings-icon" title="権限設定" target="_blank"
                style="font-size: 20px; text-decoration: none; margin-left: 10px;">⚙️</a>
        </div>
        <div class="navbar-menu-items">
            <a href="#" class="navbar-menu-item active" id="link-monthlyShift">月間シフト</a>
            <a href="シフトTo Do/シフトTodo.html" class="navbar-menu-item" target="_blank" id="link-shiftTodo">シフトTo
                Do</a>
            <a href="社員管理/employee-list.html" class="navbar-menu-item" target="_blank" id="link-employeeList">社員一覧</a>
            <a href="週間シフト/index.html" class="navbar-menu-item" target="_blank" id="link-userList">利用者一覧</a>
            <a href="週間シフト/weeklyShifts.html" class="navbar-menu-item" target="_blank" id="link-weeklyShift">週間シフト</a>
        </div>
    </div>

    <div class="container">
        <div class="header-controls">
            <div class="month-header">
                <button id="prev-month">◀</button>
                <h1 id="month-display"></h1>
                <button id="next-month">▶</button>
            </div>
            <div class="header-actions">
                <div class="search-container">
                    <input type="text" id="userSearchInput" placeholder="利用者名で検索" list="user-search-suggestions">
                    <datalist id="user-search-suggestions"></datalist>
                    <button id="searchPrevBtn" title="前へ">▲</button>
                    <button id="searchNextBtn" title="次へ">▼</button>
                    <span id="searchCount">0/0</span>
                </div>
                <button id="undoBtn" title="戻る (Ctrl+Z)">◀ 戻る</button>
                <button id="redoBtn" title="進む (Ctrl+Y)">進む ▶</button>
                <span id="autoSaveIndicator"
                    style="background: #28a745; color: white; padding: 7px 12px; border-radius: 6px; font-weight: bold; font-size: 12px;">✓
                    自動保存中</span>
                <button id="exportCSVBtn" style="background: #ffc107; color: #000;">エクスポート</button>
                <button id="checklistBtn" style="background: #17a2b8; color: white;">チェックリスト</button>
                <button id="limitAlertBtn" style="background: #e91e63; color: white; position: relative;">
                    支給量
                    <span id="limitAlertBadge" class="badge hidden">0</span>
                </button>
                <button id="showHistoryBtn">履歴表示</button>
                <button id="manageStaffBtn">担当者管理</button>
                <button id="changeNotificationBtn" style="background: #ff6b6b; color: white;">変更連絡</button>
            </div>
        </div>

        <div class="controls">
            <button id="create-magnet-btn">＋ 新規マグネット作成</button>
            <div id="unassigned-box" class="drop-zone">
                <h4>未割り当て</h4>
            </div>
        </div>

        <div id="shift-table-container">
            <table id="shift-table">
                <thead></thead>
                <tbody></tbody>
                <tfoot></tfoot>
            </table>
        </div>
    </div>

    <div id="createMagnetModal" class="modal-overlay">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0;">新規マグネット作成</h2>
                <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="modal-break-checkbox" style="cursor: pointer;">
                    <span>中抜け</span>
                </label>
            </div>
            <form id="createMagnetForm">
                <div class="modal-form-group">
                    <label for="modal-staff-search">担当者を検索</label>
                    <input type="search" id="modal-staff-search" placeholder="担当者名で検索..." list="staff-suggestions">
                    <datalist id="staff-suggestions"></datalist>
                </div>
                <div class="modal-form-group">
                    <label for="modal-user-search">利用者を検索</label>
                    <input type="search" id="modal-user-search" placeholder="利用者名で検索..." list="user-suggestions">
                    <datalist id="user-suggestions"></datalist>
                </div>
                <div class="modal-form-group">
                    <label for="modal-date-input">日付（日のみ）</label>
                    <input type="number" id="modal-date-input" min="1" max="31" placeholder="日を入力（例: 15）" required>
                </div>
                <!-- 1段目：サービス名（自由入力） -->
                <div class="modal-form-group">
                    <label for="modal-service-name-input">サービス名</label>
                    <input type="text" id="modal-service-name-input" placeholder="自由にサービス名を入力（例: 訪問入浴）">
                </div>

                <!-- 2段目：サービス内容選択エリア（ステップ遷移型） -->
                <div class="modal-form-group">
                    <label for="modal-service-display"
                        style="display: inline-flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                        <span>サービス内容</span>
                        <span
                            style="display: inline-flex; align-items: center; gap: 4px; font-size: 12px; white-space: nowrap;">
                            <input type="checkbox" id="modal-night-flag" style="cursor: pointer;">
                            <span>夜朝</span>
                        </span>
                    </label>
                    <div style="position: relative;">
                        <input type="text" id="modal-service-display" placeholder="クリックしてサービスを選択..." readonly required
                            style="cursor: pointer;">
                        <input type="hidden" id="modal-service-input">
                        <div id="service-selector-dropdown"
                            style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ccc; border-radius: 4px; max-height: 350px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
                        </div>
                    </div>
                </div>
                <div class="modal-form-group">
                    <label>時間</label>
                    <div class="time-inputs">
                        <input type="text" id="modal-start-time" required>
                        <span>-</span>
                        <input type="text" id="modal-end-time" required>
                    </div>
                </div>
                <div style="text-align: right; margin-top: 20px;">
                    <button type="button" id="modal-cancel-btn">キャンセル</button>
                    <button type="submit">保存</button>
                </div>
            </form>
        </div>
    </div>

    <div id="record-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>サービス記録内容</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div style="display: flex; gap: 10px;">
                    <div class="modal-form-group" style="flex: 1;"><label>予定時間:</label><input type="text"
                            id="record-scheduled-time" readonly></div>
                    <div class="modal-form-group" style="flex: 1;"><label>実績時間:</label><input type="text"
                            id="actualTimeInput" readonly></div>
                </div>
                <div class="modal-form-group"><label>サービス内容:</label><input type="text" id="record-service-content"
                        readonly></div>
                <div style="display: flex; gap: 10px;">
                    <div class="modal-form-group" style="flex: 1;"><label>担当者:</label><input type="text"
                            id="record-staff" readonly></div>
                    <div class="modal-form-group" style="flex: 1;"><label>利用者:</label><input type="text"
                            id="record-user" readonly></div>
                </div>
                <div class="modal-form-group"><label>介護内容:</label><textarea id="record-care-details"
                        readonly></textarea></div>
                <div class="modal-form-group"><label>様子・バイタル:</label><textarea id="record-vitals" readonly></textarea>
                </div>
                <div class="modal-form-group"><label>指示内容:</label><textarea id="record-instructions"
                        readonly></textarea></div>
                <div class="modal-form-group"><label>特記事項:</label><textarea id="record-special-notes"
                        readonly></textarea></div>
            </div>
            <div class="modal-footer">
                <button id="record-edit-btn">編集</button>
                <button id="record-approve-btn" style="background-color: #dc2626; color: white;">承認</button>
                <button>振替</button>
                <button id="record-save-btn">閉じる</button>
            </div>
        </div>
    </div>

    <div id="staff-management-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>担当者管理</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <p
                    style="background-color: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 11px;">
                    <strong>注意:</strong> 担当者リストはFirebaseの「uses」コレクションから自動的に読み込まれます。<br>
                    ここで手動で追加・削除した担当者は、ページをリロードするとFirebaseのデータで上書きされます。
                </p>
                <p>ドラッグ＆ドロップで順番を入れ替えられます。</p>
                <ul id="staff-list-editor">
                </ul>
                <div class="add-staff-container modal-form-group">
                    <input type="text" id="new-staff-name-input" placeholder="新しい担当者名"
                        list="firebase-staff-suggestions">
                    <datalist id="firebase-staff-suggestions"></datalist>
                    <input type="text" id="new-staff-type-display" placeholder="職種（自動入力）" readonly
                        style="background-color: #f0f0f0; cursor: not-allowed;">
                    <input type="text" id="new-staff-gender-display" placeholder="性別（自動入力）" readonly
                        style="background-color: #f0f0f0; cursor: not-allowed; width: 80px;">
                    <button id="add-new-staff-btn" class="modal-footer-btn">追加</button>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button id="close-staff-modal-btn">閉じて反映</button>
        </div>
    </div>
    </div>

    <div id="staff-info-modal" class="modal-overlay">
        <div class="modal-content" style="width: 800px; max-width: 95%;">
            <div class="modal-header">
                <h2 id="staff-info-modal-title">担当者情報</h2>
                <button class="modal-close-btn" id="close-staff-info-modal-btn">&times;</button>
            </div>
            <form id="staff-info-form">
                <input type="hidden" id="staff-info-employee-name">

                <h3
                    style="margin-top: 0; margin-bottom: 1rem; border-bottom: 2px solid #fed7aa; padding-bottom: 0.5rem; color: #ea580c;">
                    出勤状況</h3>
                <div class="modal-form-group">
                    <div style="display: grid; grid-template-columns: 100px 1fr; gap: 0.75rem; align-items: center;">
                        <label>月曜日</label>
                        <input type="text" id="schedule-mon" placeholder="例: 終日OK、8:30~16:00">
                        <label>火曜日</label>
                        <input type="text" id="schedule-tue" placeholder="例: 終日OK、8:30~16:00">
                        <label>水曜日</label>
                        <input type="text" id="schedule-wed" placeholder="例: 終日OK、8:30~16:00">
                        <label>木曜日</label>
                        <input type="text" id="schedule-thu" placeholder="例: 終日OK、8:30~16:00">
                        <label>金曜日</label>
                        <input type="text" id="schedule-fri" placeholder="例: 終日OK、8:30~16:00">
                        <label>土曜日</label>
                        <input type="text" id="schedule-sat" placeholder="例: 終日OK、8:30~16:00">
                        <label>日曜日</label>
                        <input type="text" id="schedule-sun" placeholder="例: 終日OK、8:30~16:00">
                    </div>
                </div>

                <h3
                    style="margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #fed7aa; padding-bottom: 0.5rem; color: #ea580c;">
                    対応可能サービス</h3>
                <div class="modal-form-group">
                    <div
                        style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; border: 1px solid #efefef; padding: 1rem; border-radius: 6px;">
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="service-physical" name="service-physical"
                                style="margin-right: 0.5rem;">
                            <label for="service-physical">身体介護</label>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="service-housework" name="service-housework"
                                style="margin-right: 0.5rem;">
                            <label for="service-housework">家事援助</label>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="service-transport" name="service-transport"
                                style="margin-right: 0.5rem;">
                            <label for="service-transport">移動支援</label>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="service-accompany" name="service-accompany"
                                style="margin-right: 0.5rem;">
                            <label for="service-accompany">同行援護</label>
                        </div>
                    </div>
                </div>

                <h3
                    style="margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #fed7aa; padding-bottom: 0.5rem; color: #ea580c;">
                    移動手段</h3>
                <div class="modal-form-group">
                    <div
                        style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; border: 1px solid #efefef; padding: 1rem; border-radius: 6px;">
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="transport-bike" name="transport-bike"
                                style="margin-right: 0.5rem;">
                            <label for="transport-bike">バイク</label>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="transport-car" name="transport-car"
                                style="margin-right: 0.5rem;">
                            <label for="transport-car">車</label>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <input type="checkbox" id="transport-bicycle" name="transport-bicycle"
                                style="margin-right: 0.5rem;">
                            <label for="transport-bicycle">自転車</label>
                        </div>
                    </div>
                </div>

                <h3
                    style="margin-top: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid #fed7aa; padding-bottom: 0.5rem; color: #ea580c;">
                    備考</h3>
                <div class="modal-form-group">
                    <textarea id="staff-notes" rows="4"
                        style="width: 100%; padding: 0.75rem; border: 1px solid #efefef; border-radius: 6px; box-sizing: border-box; font-family: inherit; resize: vertical;"
                        placeholder="その他の情報を入力してください"></textarea>
                </div>

                <div class="modal-footer">
                    <button type="button" class="modal-footer-btn" id="cancel-staff-info-btn"
                        style="background: #fed7aa; color: #4a4a4a;">キャンセル</button>
                    <button type="submit" class="modal-footer-btn"
                        style="background: #fb923c; color: white;">更新する</button>
                </div>
            </form>
        </div>
    </div>

    <div id="history-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>変更履歴 (直近50件)</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <ul id="history-list">
                </ul>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn">閉じる</button>
            </div>
        </div>
    </div>

    <!-- 変更連絡一覧モーダル -->
    <div id="change-notifications-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>変更連絡一覧 (当月分)</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body">
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead>
                            <tr style="background: #f0f2f5;">
                                <th style="border: 1px solid #ddd; padding: 8px;">日付</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">利用者名</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">変更種別</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">担当者名</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">サービス名</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">時間</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">詳細</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">記録日時</th>
                            </tr>
                        </thead>
                        <tbody id="change-notifications-list">
                            <tr>
                                <td colspan="8" style="text-align: center; padding: 20px;">読み込み中...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn">閉じる</button>
            </div>
        </div>
    </div>

    <!-- 支給量超過アラートモーダル -->
    <div id="limit-alert-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>⚠ 支給量超過アラート</h2>
                <button class="modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" style="padding: 15px 15px 0 15px;">
                <div id="limit-alert-summary"
                    style="background: #fff3cd; border: 1px solid #ffc107; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                    <p style="margin: 0; color: #856404; font-weight: bold;">
                        <span id="limit-alert-count">0</span>件のサービスが月間支給量を超過しています
                    </p>
                </div>
                <div style="overflow-x: auto;">
                    <table style="width: auto; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">利用者名</th>
                                <th style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">サービス</th>
                                <th style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">支給量</th>
                                <th style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">使用量</th>
                                <th style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">超過量</th>
                            </tr>
                        </thead>
                        <tbody id="limit-alert-list">
                            <tr>
                                <td colspan="5" style="text-align: center; padding: 16px; color: #6c757d;">
                                    支給量を超過しているサービスはありません</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer" style="margin: 10px 0 0 0; padding: 10px 15px;">
                <button class="modal-close-btn" style="background: #6c757d; color: white;">閉じる</button>
            </div>
        </div>
    </div>

    <!-- マグネット用コンテキストメニュー -->
    <div id="context-menu" class="context-menu">
        <div class="context-menu-item" id="context-move">移動</div>
        <div class="context-menu-item" id="context-accompany">同行</div>
        <div class="context-menu-item" id="context-duplicate" style="display: none;">複製</div>
        <div class="context-menu-item" id="context-company-burden">会社負担</div>
        <div class="context-menu-item" id="context-cancel">キャンセル</div>
        <div class="context-menu-item delete" id="context-delete">削除</div>
    </div>

    <!-- セル用コンテキストメニュー -->
    <div id="cell-context-menu" class="context-menu">
        <div class="context-menu-item" id="cell-context-add">追加</div>
        <div class="context-menu-item" id="cell-context-koukyu">公休</div>
        <div class="context-menu-item" id="cell-context-yuukyu">有休</div>
        <div class="context-menu-item" id="cell-context-tokkyu">特休</div>
        <div class="context-menu-item" id="cell-context-clear">クリア</div>
    </div>

    <!-- DEMO VERSION: デモバナー -->
    <div
        style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px 20px; text-align: center; font-weight: 600; position: fixed; top: 0; left: 0; right: 0; z-index: 9999;">
        ⚠️ デモ版 - すべてのデータは架空のものです
    </div>
    <style>
        body {
            padding-top: 45px !important;
        }
    </style>

    <!-- グローバル設定（スコープ問題の解決） -->
    <script>
        // ========================================
        // DEMO VERSION - Firebase Mocking
        // ========================================
        window.DEBUG = false;
        window.log = (...args) => { if (window.DEBUG) console.log(...args); };
        window.warn = (...args) => { if (window.DEBUG) console.warn(...args); };

        window.SHIFT_ROOT = 'monthly_shifts';
        window.MAGNET_PLACEMENTS = 'magnet_placements';
        window.toYM = d => (d && d.length >= 7) ? d.slice(0, 7) : 'unknown';
        window.IS_DEMO = true;

        // ダミーデータ定義
        window.DEMO_USERS = [
            { id: '0001', name: '山本 一夫', serviceLimits: [{ type: '訪問介護', monthlyLimit: 30 }] },
            { id: '0002', name: '小林 幸子', serviceLimits: [{ type: '居宅介護', monthlyLimit: 25 }] },
            { id: '0003', name: '加藤 正男', serviceLimits: [{ type: '重度訪問介護', monthlyLimit: 50 }] },
            { id: '0004', name: '渡辺 きよ', serviceLimits: [{ type: '訪問介護', monthlyLimit: 20 }] },
            { id: '0005', name: '伊藤 勇', serviceLimits: [{ type: '居宅介護', monthlyLimit: 15 }] },
            { id: '0006', name: '中村 節子', serviceLimits: [{ type: '訪問介護', monthlyLimit: 25 }] }
        ];

        window.DEMO_HELPERS = [
            { id: 'EMP001', name: '田中 太郎', type: 'サ責', gender: '男' },
            { id: 'EMP002', name: '佐藤 花子', type: 'ヘルパー', gender: '女' },
            { id: 'EMP003', name: '鈴木 一郎', type: 'ヘルパー', gender: '男' },
            { id: 'EMP004', name: '高橋 美咲', type: 'ヘルパー', gender: '女' },
            { id: 'EMP005', name: '山田 健太', type: 'ヘルパー', gender: '男' }
        ];

        // ダミーシフト生成
        window.DEMO_PLACEMENTS = [];
        (function generateDemoShifts() {
            const today = new Date();
            const yearMonth = today.toISOString().slice(0, 7);
            const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            const serviceTypes = ['身体', '家事', '移動', '居介'];
            let placementId = 1;

            for (let day = 1; day <= daysInMonth; day++) {
                const date = `${yearMonth}-${String(day).padStart(2, '0')}`;
                // 各日に2-4件のシフトを生成
                const numShifts = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < numShifts; i++) {
                    const user = window.DEMO_USERS[Math.floor(Math.random() * window.DEMO_USERS.length)];
                    const helper = window.DEMO_HELPERS[Math.floor(Math.random() * window.DEMO_HELPERS.length)];
                    const startHour = 8 + Math.floor(Math.random() * 8);
                    const duration = 1 + Math.floor(Math.random() * 2);

                    window.DEMO_PLACEMENTS.push({
                        id: `demo-magnet-${placementId++}`,
                        date: date,
                        userName: user.name,
                        userId: user.id,
                        staff: helper.name,
                        serviceType: serviceTypes[Math.floor(Math.random() * serviceTypes.length)],
                        serviceName: serviceTypes[Math.floor(Math.random() * serviceTypes.length)],
                        time: `${String(startHour).padStart(2, '0')}:00-${String(startHour + duration).padStart(2, '0')}:00`,
                        startTime: `${String(startHour).padStart(2, '0')}:00`,
                        endTime: `${String(startHour + duration).padStart(2, '0')}:00`
                    });
                }
            }
        })();
        console.log('[DEMO] 月間シフト初期化完了:', window.DEMO_PLACEMENTS.length, '件のダミーシフト');


        // DEMO: Pre-populate localStorage with staff data so enabledStaffSet initializes correctly
        const demoStaffNames = window.DEMO_HELPERS.map(h => h.name);
        const demoStaffListWithInfo = window.DEMO_HELPERS.map(h => ({
            name: h.name,
            type: h.type,
            gender: h.gender,
            staffInfo: null
        }));

        // Only populate if not already set (to preserve user's selections)
        if (!localStorage.getItem('staffList') || !localStorage.getItem('staffListWithInfo')) {
            localStorage.setItem('staffList', JSON.stringify(demoStaffNames));
            localStorage.setItem('staffListWithInfo', JSON.stringify(demoStaffListWithInfo));
            localStorage.setItem('enabledStaff', JSON.stringify(demoStaffNames));
            console.log('[DEMO] localStorage pre-populated with staff data:', demoStaffNames);
        }
    </script>


    <!-- Firebase Mock -->
    <script type="module">
        console.log('[DEMO] Firebase Mock Module initialized');

        // Mock Firestore functions
        const mockDoc = (db, ...paths) => ({ path: paths.join('/'), id: paths[paths.length - 1] });
        const mockCollection = (db, ...paths) => ({ path: paths.join('/'), type: 'collection' });

        const mockGetDocs = async (ref) => {
            console.log('[DEMO] getDocs called for:', ref?.path || 'unknown');

            if (ref?.path === 'riyousya') {
                return {
                    docs: window.DEMO_USERS.map(u => ({
                        id: u.id,
                        data: () => u,
                        ref: { id: u.id, collection: (name) => mockCollection(null, `riyousya/${u.id}/${name}`) }
                    })),
                    size: window.DEMO_USERS.length,
                    empty: false
                };
            }
            if (ref?.path === 'uses') {
                return {
                    docs: window.DEMO_HELPERS.map(h => ({
                        id: h.id,
                        data: () => h
                    })),
                    size: window.DEMO_HELPERS.length,
                    empty: false
                };
            }
            return { docs: [], size: 0, empty: true };
        };

        const mockGetDoc = async (ref) => {
            console.log('[DEMO] getDoc called for:', ref?.path || ref?.id || 'unknown');
            return { exists: () => false, data: () => null };
        };

        const mockSetDoc = async (ref, data) => { console.log('[DEMO] setDoc (無効化)'); return Promise.resolve(); };
        const mockAddDoc = async (ref, data) => { console.log('[DEMO] addDoc (無効化)'); return { id: 'demo-' + Date.now() }; };
        const mockUpdateDoc = async (ref, data) => { console.log('[DEMO] updateDoc (無効化)'); return Promise.resolve(); };
        const mockDeleteDoc = async (ref) => { console.log('[DEMO] deleteDoc (無効化)'); return Promise.resolve(); };
        const mockQuery = (...args) => args[0];
        const mockWhere = () => (ref) => ref;
        const mockLimit = () => (ref) => ref;
        const mockOrderBy = () => (ref) => ref;
        const mockServerTimestamp = () => new Date().toISOString();
        const mockOnSnapshot = (ref, callback) => {
            setTimeout(() => callback({ docs: [] }), 100);
            return () => { };
        };

        // グローバルに公開
        window.db = { type: 'mock-firestore' };
        window.firebaseDB = window.db;
        window.firestoreUtils = {
            collection: mockCollection, getDocs: mockGetDocs, addDoc: mockAddDoc,
            doc: mockDoc, setDoc: mockSetDoc, getDoc: mockGetDoc, query: mockQuery,
            where: mockWhere, limit: mockLimit, deleteDoc: mockDeleteDoc,
            updateDoc: mockUpdateDoc, onSnapshot: mockOnSnapshot
        };
        window.firebaseModules = {
            collection: mockCollection, getDocs: mockGetDocs, addDoc: mockAddDoc,
            doc: mockDoc, setDoc: mockSetDoc, getDoc: mockGetDoc, query: mockQuery,
            where: mockWhere, limit: mockLimit, deleteDoc: mockDeleteDoc,
            updateDoc: mockUpdateDoc, onSnapshot: mockOnSnapshot,
            orderBy: mockOrderBy, serverTimestamp: mockServerTimestamp
        };
        console.log('[DEMO] Firebase Mock modules exported');

        // DEMO VERSION: fetchUsers と fetchHelpers をモック
        window.fetchUsers = async function () {
            console.log('[DEMO] fetchUsers called - returning demo users');
            return window.DEMO_USERS.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
        };

        window.fetchHelpers = async function () {
            console.log('[DEMO] fetchHelpers called - returning demo helpers');
            return window.DEMO_HELPERS.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
        };

        window.setupUserRealtimeSync = function (callback) {
            console.log('[DEMO] setupUserRealtimeSync - immediate callback with demo users');
            setTimeout(() => callback(window.DEMO_USERS), 100);
            return () => { };
        };

        window.setupStaffRealtimeSync = function (callback) {
            console.log('[DEMO] setupStaffRealtimeSync - immediate callback with demo helpers');
            setTimeout(() => callback(window.DEMO_HELPERS), 100);
            return () => { };
        };

        window.loadMagnetPlacements = async function (yearMonth, startDay, endDay) {
            console.log('[DEMO] loadMagnetPlacements called:', yearMonth, startDay, endDay);
            // 指定月のプレースメントをフィルタリング
            const filtered = window.DEMO_PLACEMENTS.filter(p => p.date.startsWith(yearMonth));
            return filtered;
        };

        window.saveMagnetPlacements = async function (yearMonth, placements) {
            console.log('[DEMO] saveMagnetPlacements (無効化):', yearMonth, placements.length, '件');
            return Promise.resolve();
        };

        window.saveShift = async function (shift) {
            console.log('[DEMO] saveShift (無効化):', shift);
            return Promise.resolve();
        };

        console.log('[DEMO] All demo functions exported');

        const SHIFT_ROOT = window.SHIFT_ROOT;
        const MAGNET_PLACEMENTS = window.MAGNET_PLACEMENTS;
        const toYM = window.toYM;


        // リアルタイム更新用のコールバック関数
        let userRealtimeCallback = null;

        // DEMO VERSION: グローバルモックを使用
        function setupUserRealtimeSync(callback) {
            console.log('[DEMO] ES6 module setupUserRealtimeSync -> calling global mock');
            return window.setupUserRealtimeSync(callback);
        }


        // DEMO VERSION: グローバルモックを使用
        async function fetchUsers() {
            console.log('[DEMO] ES6 module fetchUsers -> calling global mock');
            return window.fetchUsers();
        }


        // 担当者リアルタイム更新用のコールバック関数
        let staffRealtimeCallback = null;

        // DEMO VERSION: グローバルモックを使用
        function setupStaffRealtimeSync(callback) {
            console.log('[DEMO] ES6 module setupStaffRealtimeSync -> calling global mock');
            return window.setupStaffRealtimeSync(callback);
        }

        // DEMO VERSION: グローバルモックを使用
        async function fetchHelpers() {
            console.log('[DEMO] ES6 module fetchHelpers -> calling global mock');
            return window.fetchHelpers();
        }


        // DEMO VERSION: 保存系関数をモック化
        async function saveShift(shift) {
            console.log('[DEMO] ES6 module saveShift -> mock (無効化)');
            return window.saveShift(shift);
        }

        // DEMO VERSION: 削除系関数をモック化
        async function deleteShiftsForMonth(yearMonth) {
            console.log('[DEMO] deleteShiftsForMonth (無効化):', yearMonth);
            return Promise.resolve();
        }

        async function deleteSpecificShift(date, userName, startTime, endTime, serviceType) {
            console.log('[DEMO] deleteSpecificShift (無効化):', date, userName);
            return Promise.resolve();
        }

        // DEMO VERSION: マグネット配置関数をモック化
        async function saveMagnetPlacements(yearMonth, placements) {
            console.log('[DEMO] ES6 module saveMagnetPlacements -> mock (無効化)');
            return window.saveMagnetPlacements(yearMonth, placements);
        }

        async function loadMagnetPlacements(yearMonth, startDay = null, endDay = null) {
            console.log('[DEMO] ES6 module loadMagnetPlacements -> mock:', yearMonth, startDay, endDay);
            return window.loadMagnetPlacements(yearMonth, startDay, endDay);
        }

        window.firebaseAPI = { fetchUsers, fetchHelpers, setupUserRealtimeSync, setupStaffRealtimeSync, saveShift, saveMagnetPlacements, loadMagnetPlacements, deleteShiftsForMonth, deleteSpecificShift };

    </script>

    <!-- New Module Loader -->
    <script type="module" src="module_loader.js"></script>

    <!-- script.js を無効化: index.html 内で全機能を実装済み -->
    <!-- <script src="script.js?v=2025103122"></script> -->
    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            console.log('🟢 月間シフト: DOMContentLoaded イベント発火');
            console.log('🟢 JavaScriptが正常に実行されています');

            // グローバル関数への参照
            const log = window.log;
            const warn = window.warn;
            const MAGNET_PLACEMENTS = window.MAGNET_PLACEMENTS;

            // 担当者情報（名前、職種、性別を含む）
            let staffList = JSON.parse(localStorage.getItem('staffListWithInfo')) || [];

            // staffListが空で、古い形式のstaffListがある場合は変換
            if (staffList.length === 0) {
                const oldStaffList = JSON.parse(localStorage.getItem('staffList')) || [];
                if (oldStaffList.length > 0) {
                    staffList = oldStaffList.map(name => {
                        if (typeof name === 'string') {
                            return { name: name, type: '', gender: '' };
                        }
                        return name;
                    });
                    localStorage.setItem('staffListWithInfo', JSON.stringify(staffList));
                }
            }

            // 後方互換性のため、staffNames配列も維持（名前のみ）
            let staffNames = staffList.map(s => s.name || s);

            // シフトに表示する担当者を管理（チェックボックスで制御）
            // ローカルストレージから読み込み（既存担当者は全員有効化）
            let enabledStaffSet = new Set(JSON.parse(localStorage.getItem('enabledStaff')) || staffNames);

            // enabledStaffSetが空なら既存の担当者全員を有効化
            if (enabledStaffSet.size === 0 && staffNames.length > 0) {
                enabledStaffSet = new Set(staffNames);
                localStorage.setItem('enabledStaff', JSON.stringify([...enabledStaffSet]));
            }

            // シフトテーブルに表示する担当者リストを取得する関数
            function getEnabledStaffList() {
                return staffList.filter(s => enabledStaffSet.has(s.name));
            }

            function getEnabledStaffNames() {
                return staffNames.filter(name => enabledStaffSet.has(name));
            }

            const userList = JSON.parse(localStorage.getItem('userList')) || {};
            let changeHistory = JSON.parse(localStorage.getItem('changeHistory')) || [];
            let moveOriginInfo = null;

            // Undo/Redo用のスタック
            let undoStack = [];
            let redoStack = [];
            const MAX_UNDO_STACK = 50;

            // デフォルトの職種・性別を割り当てる関数（Firebaseから取得した担当者用）
            function assignDefaultStaffInfo(name, index) {
                // インデックスに応じて適当に職種と性別を割り当て
                const types = [
                    'ヘルパー（社保加入）',
                    'ヘルパー（社保未加入）',
                    '社員（残業あり）',
                    '社員（残業なし）',
                    '社員（管理者）',
                    '事務員'
                ];
                const genders = ['男', '女'];

                // 名前から推測（簡易版）
                const type = types[index % types.length];
                const gender = genders[index % genders.length];

                return { name, type, gender };
            }

            // Firebaseからヘルパー（担当者）リストを読み込む（優先）
            if (window.firebaseAPI && typeof window.firebaseAPI.fetchHelpers === 'function') {
                try {
                    const helpers = await window.firebaseAPI.fetchHelpers();
                    if (helpers && helpers.length > 0) {
                        // ローカルストレージに保存されている職種・性別情報を取得
                        const savedStaffList = JSON.parse(localStorage.getItem('staffListWithInfo')) || [];
                        const savedStaffMap = new Map(savedStaffList.map(s => [s.name || s, s]));

                        // Firebaseから取得した担当者を新しい形式に変換
                        staffList = helpers.map((helper, index) => {
                            // 既にローカルに保存されている情報があればそれを使用
                            if (savedStaffMap.has(helper.name)) {
                                const saved = savedStaffMap.get(helper.name);
                                return {
                                    name: helper.name,
                                    type: helper.type || saved.type || '',
                                    gender: helper.gender || saved.gender || '',
                                    staffInfo: helper.staffInfo || saved.staffInfo || null
                                };
                            }
                            // Firebaseのデータを使用（なければデフォルト割り当て）
                            return {
                                name: helper.name,
                                type: helper.type || '',
                                gender: helper.gender || '',
                                staffInfo: helper.staffInfo || null
                            };
                        });

                        staffNames = staffList.map(s => s.name);

                        // ローカルストレージにも保存（バックアップとして）
                        localStorage.setItem('staffListWithInfo', JSON.stringify(staffList));
                        localStorage.setItem('staffList', JSON.stringify(staffNames));
                        console.log('担当者リストをFirebaseから読み込みました:', staffNames);

                        // リアルタイム同期をセットアップ（担当者追加時に自動更新）
                        if (typeof window.firebaseAPI.setupStaffRealtimeSync === 'function') {
                            window.firebaseAPI.setupStaffRealtimeSync((updatedHelpers) => {
                                console.log('🔄 担当者リストがリアルタイム更新されました:', updatedHelpers.length, '名');

                                const oldStaffNames = [...staffNames];
                                const newNames = updatedHelpers.map(h => h.name);

                                // staffListを常に最新データで更新（staffInfoなどの変更も反映するため）
                                staffList = updatedHelpers.map(helper => ({
                                    name: helper.name,
                                    type: helper.type || '',
                                    gender: helper.gender || '',
                                    staffInfo: helper.staffInfo || null
                                }));
                                staffNames = staffList.map(s => s.name);

                                // ローカルストレージを更新
                                localStorage.setItem('staffListWithInfo', JSON.stringify(staffList));
                                localStorage.setItem('staffList', JSON.stringify(staffNames));

                                // 名前リストに変更があったかチェック（UI更新用）
                                const namesChanged = newNames.length !== oldStaffNames.length ||
                                    newNames.some((name, i) => name !== oldStaffNames[i]);

                                if (namesChanged) {
                                    console.log('🔄 担当者名リストに変更あり');

                                    // 新規追加された担当者を検出
                                    const addedStaff = newNames.filter(name => !oldStaffNames.includes(name));
                                    if (addedStaff.length > 0) {
                                        console.log('🔄 新規担当者を検出（チェックなしで追加）:', addedStaff);
                                    }

                                    // 担当者のdatalistを更新
                                    if (typeof renderStaffSuggestions === 'function') {
                                        renderStaffSuggestions();
                                    }

                                    // 担当者管理モーダルが開いている場合はリストを更新
                                    const staffModal = document.getElementById('staff-management-modal');
                                    if (staffModal && staffModal.classList.contains('visible')) {
                                        if (typeof renderStaffListEditor === 'function') {
                                            renderStaffListEditor();
                                        }
                                    }

                                    // 注：テーブルは自動再描画しない
                                    console.log('🔄 新規担当者の追加を検出。担当者管理で有効化するとシフトに表示されます。');
                                } else {
                                    console.log('🔄 担当者情報（詳細）のみ更新されました');
                                }
                            });
                            console.log('🔄 担当者リストのリアルタイム同期を設定しました');
                        }
                    } else {
                        console.warn('Firebaseにヘルパーデータがないため、ローカルストレージのデータを使用します');
                        // すでに初期化時に読み込まれているのでそのまま使用
                    }
                } catch (err) {
                    console.error('ヘルパーデータの読み込みエラー:', err);
                    console.warn('ローカルストレージのデータを使用します');
                    // すでに初期化時に読み込まれているのでそのまま使用
                }
            }

            let currentDate = new Date();
            let draggedMagnet = null;
            let currentEditingMagnetId = null;
            let cutMagnet = null;
            let fetchedUsers = [];

            const table = document.getElementById('shift-table');
            const monthDisplay = document.getElementById('month-display');
            const prevMonthBtn = document.getElementById('prev-month');
            const nextMonthBtn = document.getElementById('next-month');
            const manageStaffBtn = document.getElementById('manageStaffBtn');
            const createMagnetBtn = document.getElementById('create-magnet-btn');
            const unassignedBox = document.getElementById('unassigned-box');
            const createModal = document.getElementById('createMagnetModal');
            const createModalForm = document.getElementById('createMagnetForm');
            const createModalStaffSearch = document.getElementById('modal-staff-search');
            const createModalUserSearch = document.getElementById('modal-user-search');
            const createModalDateInput = document.getElementById('modal-date-input');
            const createModalCancelBtn = document.getElementById('modal-cancel-btn');
            const createModalBreakCheckbox = document.getElementById('modal-break-checkbox');
            const recordModal = document.getElementById('record-modal');
            const recordEditBtn = document.getElementById('record-edit-btn');
            const recordSaveBtn = document.getElementById('record-save-btn');
            const recordCancelBtn = document.getElementById('record-cancel-btn');
            const staffModal = document.getElementById('staff-management-modal');
            const staffListEditor = document.getElementById('staff-list-editor');
            const newStaffNameInput = document.getElementById('new-staff-name-input');
            const addNewStaffBtn = document.getElementById('add-new-staff-btn');
            const closeStaffModalBtn = document.getElementById('close-staff-modal-btn');
            let draggedStaffItem = null;
            const historyModal = document.getElementById('history-modal');
            const showHistoryBtn = document.getElementById('showHistoryBtn');
            const changeNotificationBtn = document.getElementById('changeNotificationBtn');
            const checklistBtn = document.getElementById('checklistBtn');
            const historyList = document.getElementById('history-list');
            const autoSaveIndicator = document.getElementById('autoSaveIndicator');

            // 支給量アラート関連
            const limitAlertBtn = document.getElementById('limitAlertBtn');
            const limitAlertBadge = document.getElementById('limitAlertBadge');
            const limitAlertModal = document.getElementById('limit-alert-modal');
            const limitAlertList = document.getElementById('limit-alert-list');
            const limitAlertCount = document.getElementById('limit-alert-count');

            // 時間ピッカー初期化（5分刻み固定）
            const initModalTimePickers = () => {
                const selector = "#modal-start-time, #modal-end-time";
                document.querySelectorAll(selector).forEach(el => {
                    if (el._flatpickr) el._flatpickr.destroy();
                    el.readOnly = false;
                });
                flatpickr(selector, {
                    enableTime: true,
                    noCalendar: true,
                    dateFormat: "H:i",
                    time_24hr: true,
                    minuteIncrement: 5,
                    locale: "ja",
                    allowInput: true,
                    scrollInput: true,
                    disableMobile: true
                });
                attachTimeWheelHandlers(selector);
            };

            // 初期化（サービスユーティリティ読み込み前でも適用）
            initModalTimePickers();

            // 時間入力にホイール操作で5分刻み増減を付与
            function attachTimeWheelHandlers(selector) {
                document.querySelectorAll(selector).forEach(el => {
                    el.addEventListener('wheel', e => {
                        if (!el._flatpickr) return;
                        e.preventDefault();
                        const inst = el._flatpickr;
                        const base = inst.selectedDates[0] || inst.config.defaultDate || new Date();
                        const stepMinutes = inst.config.minuteIncrement || 5;
                        const delta = e.deltaY > 0 ? stepMinutes : -stepMinutes;
                        const newDate = new Date(base.getTime() + delta * 60000);
                        inst.setDate(newDate, true);
                    }, { passive: false });
                });
            }

            document.addEventListener('serviceUtilsReady', () => {
                const modalServiceDisplay = document.getElementById('modal-service-display');
                const modalServiceInput = document.getElementById('modal-service-input');
                const serviceSelectorDropdown = document.getElementById('service-selector-dropdown');
                const startTimeInput = document.getElementById('modal-start-time');
                const endTimeInput = document.getElementById('modal-end-time');
                const nightFlag = document.getElementById('modal-night-flag');

                // Flatpickrで時間選択UIを初期化（再適用）
                initModalTimePickers();

                // 候補リストをレンダリングするシンプルな関数
                const renderCandidates = () => {
                    serviceSelectorDropdown.innerHTML = ''; // 中身をクリア
                    const startTime = startTimeInput.value;
                    const endTime = endTimeInput.value;

                    // スタイルの定義
                    const itemStyle = `padding: 12px 15px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 14px; transition: background-color 0.2s;`;
                    const itemHoverStyle = `background-color: #f5f5f5;`;
                    const headerStyle = `padding: 10px 15px; font-size: 12px; font-weight: bold; color: #666; background-color: #fafafa; border-bottom: 1px solid #ddd;`;

                    // 時刻が入力されているかチェック
                    if (!startTime || !endTime) {
                        const message = document.createElement('div');
                        message.textContent = 'エラー: 開始時刻と終了時刻を入力してください。';
                        message.style.cssText = `${headerStyle} color: #dc3545;`;
                        serviceSelectorDropdown.appendChild(message);
                        return;
                    }

                    try {
                        const candidates = getCandidateServicesLocal(startTime, endTime, 'care');

                        if (candidates.length === 0) {
                            const message = document.createElement('div');
                            message.textContent = '該当するサービスがありません。';
                            message.style.cssText = headerStyle;
                            serviceSelectorDropdown.appendChild(message);
                        } else {
                            candidates.forEach(service => {
                                const item = document.createElement('div');
                                item.innerHTML = `
                                <span style="font-weight: 500;">${service.label}</span>
                                <span style="font-size: 11px; color: #777; margin-left: 8px;">(${service.code})</span>
                            `;
                                item.style.cssText = itemStyle;
                                item.addEventListener('mouseenter', e => e.target.style.backgroundColor = itemHoverStyle);
                                item.addEventListener('mouseleave', e => e.target.style.backgroundColor = 'transparent');
                                item.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    modalServiceDisplay.value = service.label;
                                    modalServiceInput.value = service.code;
                                    serviceSelectorDropdown.style.display = 'none';
                                });
                                serviceSelectorDropdown.appendChild(item);
                            });
                        }
                    } catch (error) {
                        console.error("サービス候補の取得中にエラーが発生しました:", error);
                        const message = document.createElement('div');
                        message.textContent = `エラー: ${error.message}`;
                        message.style.cssText = `${headerStyle} color: #dc3545;`;
                        serviceSelectorDropdown.appendChild(message);
                    }
                };

                // イベントリスナーの設定
                modalServiceDisplay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    renderCandidates(); // 候補をレンダリング
                    serviceSelectorDropdown.style.display = 'block';
                });

                // 時間が変更されたら、ドロップダウンが開いていればリストを再描画
                const updateOnTimeChange = () => {
                    if (serviceSelectorDropdown.style.display === 'block') {
                        renderCandidates();
                    }
                };
                startTimeInput.addEventListener('change', updateOnTimeChange);
                endTimeInput.addEventListener('change', updateOnTimeChange);
                if (nightFlag) {
                    nightFlag.addEventListener('change', () => {
                        // 夜朝切り替え時は選択をクリアして再描画
                        modalServiceDisplay.value = '';
                        modalServiceInput.value = '';
                        if (serviceSelectorDropdown.style.display === 'block') {
                            renderCandidates();
                        }
                    });
                }

                // ドロップダウンの外側をクリックしたら閉じる
                document.addEventListener('click', (e) => {
                    if (!serviceSelectorDropdown.contains(e.target) && e.target !== modalServiceDisplay) {
                        serviceSelectorDropdown.style.display = 'none';
                    }
                });
            });

            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            console.log('undoBtn:', undoBtn, 'redoBtn:', redoBtn);
            const contextMenu = document.getElementById('context-menu');
            const contextMove = document.getElementById('context-move');
            const contextDelete = document.getElementById('context-delete');
            const contextDuplicate = document.getElementById('context-duplicate');
            const contextAccompany = document.getElementById('context-accompany');
            const contextCompanyBurden = document.getElementById('context-company-burden');
            const contextCancel = document.getElementById('context-cancel');
            let contextTargetMagnet = null;


            const cellContextMenu = document.getElementById('cell-context-menu');
            const cellContextAdd = document.getElementById('cell-context-add');
            const cellContextKoukyu = document.getElementById('cell-context-koukyu');
            const cellContextYuukyu = document.getElementById('cell-context-yuukyu');
            const cellContextTokkyu = document.getElementById('cell-context-tokkyu');
            const cellContextClear = document.getElementById('cell-context-clear');
            let contextTargetCell = null;

            // 現在のテーブル状態をキャプチャする関数
            function captureTableState() {
                const state = {
                    magnets: [],
                    cells: []
                };

                // すべてのマグネットの状態を保存
                document.querySelectorAll('.magnet').forEach(magnet => {
                    const parentCell = magnet.parentElement;
                    const row = parentCell.closest('tr');
                    const rowIndex = row ? Array.from(row.parentElement.children).indexOf(row) : -1;
                    const cellIndex = parentCell.cellIndex;

                    state.magnets.push({
                        id: magnet.id,
                        html: magnet.outerHTML,
                        rowIndex: rowIndex,
                        cellIndex: cellIndex,
                        parentId: parentCell.id || `cell-${rowIndex}-${cellIndex}`
                    });
                });

                // セルの背景色状態を保存（公休・有給・特休）
                // すべてのセルの状態を保存（背景色がないセルも含む）
                document.querySelectorAll('tbody td.drop-zone').forEach(cell => {
                    const row = cell.closest('tr');
                    const rowIndex = row ? Array.from(row.parentElement.children).indexOf(row) : -1;
                    const cellIndex = cell.cellIndex;

                    // 公休・有休・特休のクラスを持つかどうかを保存
                    const cellClasses = [];
                    if (cell.classList.contains('cell-koukyu')) cellClasses.push('cell-koukyu');
                    if (cell.classList.contains('cell-yuukyu')) cellClasses.push('cell-yuukyu');
                    if (cell.classList.contains('cell-tokkyu')) cellClasses.push('cell-tokkyu');

                    state.cells.push({
                        rowIndex: rowIndex,
                        cellIndex: cellIndex,
                        classes: cellClasses,
                        backgroundColor: cell.style.backgroundColor || ''
                    });
                });

                return state;
            }

            // 状態を復元する関数
            function restoreTableState(state) {
                if (!state) return;

                // すべてのマグネットをクリア
                document.querySelectorAll('.magnet').forEach(m => m.remove());

                // セルの背景色をクリア（クラスとインラインスタイルの両方）
                document.querySelectorAll('tbody td.drop-zone').forEach(cell => {
                    cell.classList.remove('cell-koukyu', 'cell-yuukyu', 'cell-tokkyu');
                    cell.style.backgroundColor = ''; // インラインスタイルもクリア
                });

                // マグネットを復元
                state.magnets.forEach(magnetData => {
                    const rows = table.querySelectorAll('tbody tr');
                    if (magnetData.rowIndex >= 0 && magnetData.rowIndex < rows.length) {
                        const row = rows[magnetData.rowIndex];
                        const cell = row.children[magnetData.cellIndex];
                        if (cell) {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = magnetData.html;
                            const magnet = tempDiv.firstChild;
                            cell.appendChild(magnet);
                        }
                    } else if (magnetData.parentId === 'unassigned-box') {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = magnetData.html;
                        const magnet = tempDiv.firstChild;
                        unassignedBox.appendChild(magnet);
                    }
                });

                // セルの背景色を復元
                state.cells.forEach(cellData => {
                    const rows = table.querySelectorAll('tbody tr');
                    if (cellData.rowIndex >= 0 && cellData.rowIndex < rows.length) {
                        const row = rows[cellData.rowIndex];
                        const cell = row.children[cellData.cellIndex];
                        if (cell) {
                            // 保存されたクラスを復元
                            if (cellData.classes && cellData.classes.length > 0) {
                                cellData.classes.forEach(cls => {
                                    if (cls === 'cell-koukyu' || cls === 'cell-yuukyu' || cls === 'cell-tokkyu') {
                                        cell.classList.add(cls);
                                        // インラインスタイルで背景色を設定
                                        if (cls === 'cell-koukyu') {
                                            cell.style.backgroundColor = '#c8e6c9';
                                        } else if (cls === 'cell-yuukyu') {
                                            cell.style.backgroundColor = '#ffe0b2';
                                        } else if (cls === 'cell-tokkyu') {
                                            cell.style.backgroundColor = '#e3f2fd';
                                        }
                                    }
                                });
                            } else {
                                // クラスがない場合は背景色をクリア
                                cell.style.backgroundColor = '';
                            }
                        }
                    }
                });

                // セルの並び順を修正し、時間を更新
                document.querySelectorAll('td.drop-zone').forEach(cell => {
                    sortMagnetsInCell(cell);
                });
                updateAllHours();
                updateLeaveCount();
                setupDragAndDrop();
            }

            // 状態を保存してスタックに追加
            function saveStateToUndo() {
                const state = captureTableState();
                undoStack.push(state);
                if (undoStack.length > MAX_UNDO_STACK) {
                    undoStack.shift(); // 古い履歴を削除
                }
                redoStack = []; // Redo スタックをクリア
                updateUndoRedoButtons();
            }

            // Undo/Redoボタンの有効/無効を更新
            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            // 元に戻す
            function undo() {
                if (undoStack.length === 0) {
                    console.log('Undo: スタックが空です');
                    return;
                }

                console.log('Undo: 実行中... スタックサイズ:', undoStack.length);
                const currentState = captureTableState();
                redoStack.push(currentState);

                const previousState = undoStack.pop();
                restoreTableState(previousState);
                updateUndoRedoButtons();
                console.log('Undo: 完了');
            }

            // やり直し
            function redo() {
                if (redoStack.length === 0) {
                    console.log('Redo: スタックが空です');
                    return;
                }

                console.log('Redo: 実行中... スタックサイズ:', redoStack.length);
                const currentState = captureTableState();
                undoStack.push(currentState);

                const nextState = redoStack.pop();
                restoreTableState(nextState);
                updateUndoRedoButtons();
                console.log('Redo: 完了');
            }

            // イベントリスナー
            if (undoBtn) undoBtn.addEventListener('click', undo);
            if (redoBtn) redoBtn.addEventListener('click', redo);

            // キーボードショートカット (Ctrl+Z, Ctrl+Y)
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    redo();
                }
            });

            // 初期化
            updateUndoRedoButtons();

            // Firebase: 利用者データを取得してdatalistに設定
            function renderUserSuggestions(users) {
                const datalist = document.getElementById('user-suggestions');
                const searchDatalist = document.getElementById('user-search-suggestions');

                datalist.innerHTML = '';
                if (searchDatalist) searchDatalist.innerHTML = '';

                users.forEach(u => {
                    // 全角スペースを半角スペースに統一
                    const normalizedName = u.name.replace(/　/g, ' ');

                    const option = document.createElement('option');
                    option.value = normalizedName;
                    datalist.appendChild(option);

                    // 検索用datalistにも追加
                    if (searchDatalist) {
                        const searchOption = document.createElement('option');
                        searchOption.value = normalizedName;
                        searchDatalist.appendChild(searchOption);
                    }
                });
            }

            // 担当者データをdatalistに設定
            function renderStaffSuggestions() {
                const datalist = document.getElementById('staff-suggestions');
                datalist.innerHTML = '';
                staffNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    datalist.appendChild(option);
                });
            }

            // 担当者管理モーダル用：チェックボックス付きリストを描画
            function renderStaffListEditor() {
                const staffListEditor = document.getElementById('staff-list-editor');
                if (!staffListEditor) return;

                staffListEditor.innerHTML = '';

                staffList.forEach((staff, index) => {
                    const isEnabled = enabledStaffSet.has(staff.name);
                    const li = document.createElement('li');
                    li.style.cssText = 'display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #eee; background-color: white; gap: 10px;';

                    // チェックボックス
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = isEnabled;
                    checkbox.dataset.staffName = staff.name;
                    checkbox.style.cssText = 'width: 18px; height: 18px; cursor: pointer;';
                    checkbox.addEventListener('change', (e) => {
                        const staffName = e.target.dataset.staffName;
                        if (e.target.checked) {
                            enabledStaffSet.add(staffName);
                            console.log('✅ 担当者を有効化:', staffName);
                        } else {
                            enabledStaffSet.delete(staffName);
                            console.log('❌ 担当者を無効化:', staffName);
                        }
                        localStorage.setItem('enabledStaff', JSON.stringify([...enabledStaffSet]));
                    });

                    // 担当者名
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'staff-name';
                    nameSpan.textContent = staff.name;
                    nameSpan.style.cssText = 'flex-grow: 1; font-weight: 500;';
                    if (!isEnabled) {
                        nameSpan.style.color = '#999';
                    }

                    // 職種タグ
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'staff-type';
                    typeSpan.textContent = staff.type || '-';
                    typeSpan.style.cssText = 'font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #e0e0e0;';

                    // 性別タグ
                    const genderSpan = document.createElement('span');
                    genderSpan.className = 'staff-gender';
                    genderSpan.textContent = staff.gender || '-';
                    genderSpan.style.cssText = 'font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #e0e0e0;';

                    // 新規追加ラベル（enabledでない場合）
                    if (!isEnabled) {
                        const newLabel = document.createElement('span');
                        newLabel.textContent = '新規';
                        newLabel.style.cssText = 'font-size: 10px; padding: 2px 6px; border-radius: 4px; background: #ff9800; color: white; font-weight: bold;';
                        li.appendChild(checkbox);
                        li.appendChild(nameSpan);
                        li.appendChild(newLabel);
                        li.appendChild(typeSpan);
                        li.appendChild(genderSpan);
                    } else {
                        li.appendChild(checkbox);
                        li.appendChild(nameSpan);
                        li.appendChild(typeSpan);
                        li.appendChild(genderSpan);
                    }

                    staffListEditor.appendChild(li);
                });

                // 有効/無効の件数を表示
                const enabledCount = staffList.filter(s => enabledStaffSet.has(s.name)).length;
                const totalCount = staffList.length;
                const infoDiv = document.createElement('div');
                infoDiv.style.cssText = 'padding: 10px; background: #f0f0f0; text-align: center; font-size: 12px; color: #666;';
                infoDiv.textContent = `シフトに表示: ${enabledCount}名 / 全${totalCount}名`;
                staffListEditor.appendChild(infoDiv);
            }

            async function loadUsersFromFirebase(onComplete) {
                console.log('🟡 loadUsersFromFirebase: 関数が呼び出されました');
                // 担当者リストをdatalistに読み込む
                renderStaffSuggestions();

                // 利用者リストをdatalistに読み込む
                console.log('🟡 firebaseAPI確認:', window.firebaseAPI ? 'あり' : 'なし');
                console.log('🟡 fetchUsers確認:', typeof window.firebaseAPI?.fetchUsers);
                if (window.firebaseAPI && typeof window.firebaseAPI.fetchUsers === 'function') {
                    try {
                        const users = await window.firebaseAPI.fetchUsers();
                        console.log('→ loadUsersFromFirebase: fetchUsers結果:', users.length, '件');
                        console.log('→ 支給量が設定されているユーザー:', users.filter(u => u.serviceLimits && u.serviceLimits.length > 0));

                        fetchedUsers = users;
                        renderUserSuggestions(users);

                        // リアルタイム同期をセットアップ（利用者追加時に自動更新）
                        if (typeof window.firebaseAPI.setupUserRealtimeSync === 'function') {
                            window.firebaseAPI.setupUserRealtimeSync((updatedUsers) => {
                                console.log('🔄 利用者リストがリアルタイム更新されました:', updatedUsers.length, '件');
                                fetchedUsers = updatedUsers;
                                renderUserSuggestions(updatedUsers);
                            });
                            console.log('🔄 利用者リストのリアルタイム同期を設定しました');
                        }

                        if (onComplete) onComplete();
                    } catch (err) {
                        console.error('利用者取得エラー:', err);
                        // フォールバック: LocalStorageから読み込む
                        const localUsers = Object.keys(userList).map(userId => ({
                            id: userId,
                            name: userList[userId].name,
                            serviceLimits: []
                        }));
                        fetchedUsers = localUsers;
                        renderUserSuggestions(localUsers);
                        if (onComplete) onComplete();
                    }
                } else {
                    console.warn('→ firebaseAPI未定義またはfetchUsers関数がない');
                    // Firebase未設定の場合はLocalStorageから
                    const localUsers = Object.keys(userList).map(userId => ({
                        id: userId,
                        name: userList[userId].name,
                        serviceLimits: []
                    }));
                    fetchedUsers = localUsers;
                    renderUserSuggestions(localUsers);
                    if (onComplete) onComplete();
                }
            }

            function getLocationName(cell) {
                if (!cell || !(cell.matches('td') || cell.id === 'unassigned-box')) {
                    return '不明';
                }
                if (cell.id === 'unassigned-box') {
                    return '未割り当てBOX';
                }
                const cellIndex = cell.cellIndex;
                if (cellIndex === 0) {
                    return '保管場所';
                }
                return staffNames[cellIndex - 2] || '不明';
            }

            function addHistoryEntry(magnetText, from, to, date) {
                const timestamp = new Date();
                const entry = {
                    time: timestamp.toLocaleString('ja-JP'),
                    magnet: magnetText.replace(/<[^>]*>?/gm, ''),
                    from: from,
                    to: to,
                    date: date
                };
                changeHistory.unshift(entry);
                changeHistory = changeHistory.slice(0, 50);
                localStorage.setItem('changeHistory', JSON.stringify(changeHistory));
            }

            function renderHistory() {
                historyList.innerHTML = '';
                if (changeHistory.length === 0) {
                    historyList.innerHTML = '<li>変更履歴はありません。</li>';
                    return;
                }
                changeHistory.forEach(entry => {
                    const li = document.createElement('li');
                    const magnetParts = entry.magnet.trim().split(' ');
                    const userName = magnetParts[0] || '';
                    const restOfMagnet = magnetParts.slice(1).join(' ');

                    li.innerHTML = `
                    <span class="history-meta">${entry.time} (${entry.date})</span>
                    「<strong class="magnet-user">${userName}</strong> ${restOfMagnet}」を
                    <strong>${entry.from}</strong> から <strong>${entry.to}</strong> へ移動
                `;
                    historyList.appendChild(li);
                });
            }

            function cancelCut() {
                if (cutMagnet) {
                    cutMagnet.classList.remove('cut');
                    cutMagnet = null;
                }
                moveOriginInfo = null;
            }

            // パフォーマンス改善: 初期表示を軽量化（今日±7日のみ描画、残りは遅延ロード）
            function renderMonthlyTable(year, month) {
                // 既存のIntersectionObserverをクリーンアップ（メモリリーク防止）
                if (lazyLoadObserver) {
                    lazyLoadObserver.disconnect();
                    lazyLoadObserver = null;
                }

                // 表示用担当者リスト（有効化された担当者のみ）
                const displayStaffList = getEnabledStaffList();
                const displayStaffNames = getEnabledStaffNames();
                console.log(`📊 シフトテーブル描画: ${displayStaffNames.length}名の担当者を表示`);

                const thead = table.querySelector('thead');
                const tbody = table.querySelector('tbody');
                const tfoot = table.querySelector('tfoot');
                thead.innerHTML = '';
                tbody.innerHTML = '';
                tfoot.innerHTML = '';

                monthDisplay.textContent = `${year}年 ${month}月`;

                const monthString = String(month).padStart(2, '0');
                const templateKey = `weeklyShiftTemplate_${year}-${monthString}`;
                const weeklyTemplate = JSON.parse(localStorage.getItem(templateKey)) || {};

                const daysInMonth = new Date(year, month, 0).getDate();

                // 初期表示日: 10月は17日、それ以外は今日または月の中央
                let currentDay;
                const today = new Date();
                if (month === 10) {
                    currentDay = 17; // 10月は常に17日を中心に表示
                } else if (year === today.getFullYear() && month === today.getMonth() + 1) {
                    currentDay = today.getDate();
                } else {
                    currentDay = Math.floor(daysInMonth / 2);
                }

                // 初期表示範囲: 基準日±3日（最小1日、最大月末）- パフォーマンス改善
                const initialStartDay = Math.max(1, currentDay - 3);
                const initialEndDay = Math.min(daysInMonth, currentDay + 3);

                // 月の日数から基本拘束時間を計算（社員（残業なし）用）
                let baseRequiredHours = 0;
                if (daysInMonth <= 28) baseRequiredHours = 160;
                else if (daysInMonth === 29) baseRequiredHours = 165;
                else if (daysInMonth === 30) baseRequiredHours = 171;
                else if (daysInMonth === 31) baseRequiredHours = 177;

                // 職種別の拘束時間を計算する関数
                function getRequiredHours(staffType) {
                    if (staffType === '社員（管理者）' || staffType === '課長') {
                        return 220; // 固定220時間
                    } else if (staffType === '社員（残業あり）') {
                        return baseRequiredHours + 30; // 基本 + 30時間
                    } else if (staffType === '社員（残業なし）') {
                        return baseRequiredHours; // 基本時間
                    } else {
                        return null; // ヘルパー、事務員は表示なし
                    }
                }

                const headerRow = document.createElement('tr');
                headerRow.innerHTML = `<th>保管場所</th><th>日付</th>`;
                displayStaffList.forEach((staff, index) => {
                    const name = staff.name || staff;
                    const type = staff.type || '';
                    const gender = staff.gender || '';
                    const typeDisplay = type ? `<div style="font-size: 10px; font-weight: normal;">${type}${gender ? `（${gender}）` : ''}</div>` : '';

                    // 担当者情報ボタンを追加（ヘルパーのみ）
                    const isHelper = type.includes('ヘルパー');
                    const staffInfoBtn = isHelper
                        ? `<button class="staff-info-btn" data-staff-name="${name}" style="background: none; border: none; cursor: pointer; padding: 2px; margin-left: 4px; vertical-align: middle;" title="担当者情報">
                        <svg style="width: 18px; height: 18px; fill: #ffaa00; vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4M11,7V13H13V7H11M11,15V17H13V15H11Z" />
                        </svg>
                    </button>`
                        : '';

                    headerRow.innerHTML += `<th>${typeDisplay}<div style="font-size: 14px; display: flex; align-items: center; justify-content: center;">${name}${staffInfoBtn}</div></th>`;
                });
                thead.appendChild(headerRow);

                const leaveInfoRow = document.createElement('tr');
                leaveInfoRow.innerHTML = `<th></th><th></th>`;
                displayStaffList.forEach((staff, index) => {
                    const name = staff.name || staff;
                    const type = staff.type || '';
                    const requiredHours = getRequiredHours(type);

                    const leaveCell = document.createElement('th');
                    leaveCell.classList.add('leave-info-cell');

                    // 拘束時間の表示を職種に応じて変更
                    const requiredHoursDisplay = requiredHours !== null ? requiredHours : '';

                    leaveCell.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px; padding: 4px 2px;">
                        <!-- 左列 -->
                        <div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">公休</span><input type="number" class="leave-input" data-staff="${name}" min="0" max="31" value="0" readonly style="width: 35px; text-align: center;">日
                                </div>
                            </div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">有休</span><input type="number" class="leave-input" data-staff="${name}" min="0" max="31" value="0" readonly style="width: 35px; text-align: center;">日
                                </div>
                            </div>
                            <div class="leave-row">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">特休</span><input type="number" class="leave-input leave-input-tokkyu" data-staff="${name}" min="0" max="31" value="0" readonly style="width: 35px; text-align: center;">日
                                </div>
                            </div>
                        </div>
                        <!-- 右列 -->
                        <div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">予定</span><input type="number" class="leave-input" data-staff="${name}" style="background-color: white; color: black; width: 35px; text-align: center;" min="0" max="999" value="${requiredHoursDisplay}" readonly>h
                                </div>
                            </div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">勤務</span><input type="number" class="leave-input" id="constraint-${name}" style="background-color: white; color: black; width: 35px; text-align: center;" value="0.0" readonly>h
                                </div>
                            </div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">実績</span><input type="number" class="leave-input" id="total-${name}" style="background-color: white; color: black; width: 35px; text-align: center;" value="0.0" readonly>h
                                </div>
                            </div>
                            <div class="leave-row" style="margin-bottom: 3px;">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">30分</span><input type="number" class="leave-input" id="thirty-min-${name}" style="background-color: white; color: black; width: 35px; text-align: center;" value="0" readonly>回
                                </div>
                            </div>
                            <div class="leave-row">
                                <div class="leave-left" style="font-size: 11px; display: flex; align-items: center; gap: 2px;">
                                    <span style="min-width: 28px;">会社</span><input type="number" class="leave-input" id="company-burden-${name}" style="background-color: white; color: black; width: 35px; text-align: center;" value="0" readonly>回
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                    leaveInfoRow.appendChild(leaveCell);
                });
                thead.appendChild(leaveInfoRow);
                const dayLabels = ['日', '月', '火', '水', '木', '金', '土'];

                // 週の開始日を追跡
                let weekStartDay = 1;

                // 全日分の行を作成（初期表示範囲のみセルに内容を追加、残りは空行）
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month - 1, day);
                    const dayOfWeekIndex = date.getDay();
                    const dayOfWeekName = dayLabels[dayOfWeekIndex];

                    const row = document.createElement('tr');
                    row.dataset.day = dayOfWeekIndex;
                    row.dataset.dayNumber = day; // 日付を記録
                    row.innerHTML += `<td class="drop-zone storage-location"></td>`;
                    row.innerHTML += `<td>${day}(${dayOfWeekName})</td>`;

                    // 初期表示範囲内の場合のみセルに内容を追加
                    const shouldRender = day >= initialStartDay && day <= initialEndDay;

                    if (shouldRender) {
                        staffNames.forEach(staffName => {
                            const cell = document.createElement('td');
                            cell.classList.add('drop-zone');

                            const magnetsForCell = weeklyTemplate[dayOfWeekName]?.[staffName] || [];
                            magnetsForCell.forEach(magnetData => {
                                const magnet = createMagnet(magnetData, true);
                                cell.appendChild(magnet);
                            });
                            sortMagnetsInCell(cell);

                            // 時間表示用の要素を追加
                            const timeSummary = document.createElement('div');
                            timeSummary.className = 'time-summary';
                            timeSummary.innerHTML = `
                            <span class="start-time">-</span>
                            <span class="end-time">-</span>
                            <span class="break-time">0:00</span>
                            <span class="work-time">0:00</span>
                        `;
                            cell.appendChild(timeSummary);

                            row.appendChild(cell);
                        });
                        row.dataset.rendered = 'true'; // 描画済みフラグ
                    } else {
                        // 未描画の行: 空のセルのみ作成（遅延ロード用）
                        staffNames.forEach(staffName => {
                            const cell = document.createElement('td');
                            cell.classList.add('drop-zone', 'lazy-load'); // lazy-loadクラスを追加
                            cell.innerHTML = '<div class="loading-placeholder" style="text-align:center;color:#999;padding:10px;">...</div>';
                            row.appendChild(cell);
                        });
                        row.dataset.rendered = 'false'; // 未描画フラグ
                    }

                    tbody.appendChild(row);

                    // 日曜日（dayOfWeekIndex === 0）または月末の場合、週合計行を挿入
                    if (dayOfWeekIndex === 0 || day === daysInMonth) {
                        const weekSummaryRow = document.createElement('tr');
                        weekSummaryRow.classList.add('week-summary-row');
                        weekSummaryRow.dataset.weekStart = weekStartDay;
                        weekSummaryRow.dataset.weekEnd = day;

                        weekSummaryRow.innerHTML = `<td>週合計</td><td>${weekStartDay}-${day}日</td>`;

                        displayStaffNames.forEach(staffName => {
                            const summaryCell = document.createElement('td');
                            summaryCell.innerHTML = `
                            <div style="font-size: 10px; line-height: 1.1; margin: 0;">
                                拘束: <span class="week-total-hours" data-staff="${staffName}">0.0</span>h
                            </div>
                            <div style="font-size: 10px; line-height: 1.1; margin: 0;">
                                サービス: <span class="week-service-hours" data-staff="${staffName}">0.0</span>h
                            </div>
                        `;
                            weekSummaryRow.appendChild(summaryCell);
                        });

                        tbody.appendChild(weekSummaryRow);

                        // 次の週の開始日を設定
                        weekStartDay = day + 1;
                    }
                }

                // tfootは空にする（月合計情報はヘッダーに表示）

                setupDragAndDrop();
                updateAllHours();

                // 遅延ロードのセットアップ
                setupLazyLoading(year, month, weeklyTemplate, dayLabels);

                // 既存のマグネット構造を修正
                setTimeout(() => {
                    fixExistingMagnetStructure();
                }, 100);

                // 基準日までスクロール（初期表示後）
                setTimeout(() => {
                    scrollToTargetDay(year, month);
                }, 300);
            }

            // 遅延ロード: IntersectionObserver で画面に表示された行を描画
            function setupLazyLoading(year, month, weeklyTemplate, dayLabels) {
                // グローバルなobserverを作成（メモリリーク防止）
                lazyLoadObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const row = entry.target;
                            if (row.dataset.rendered === 'false') {
                                // 行を描画
                                renderRow(row, year, month, weeklyTemplate, dayLabels);
                                lazyLoadObserver.unobserve(row); // 描画後は監視解除
                            }
                        }
                    });
                }, {
                    root: document.getElementById('shift-table-container'),
                    rootMargin: '100px', // 100px手前から描画開始（200px→100pxに削減）
                    threshold: 0
                });

                // 未描画の行を監視
                const rows = table.querySelectorAll('tbody tr[data-rendered="false"]');
                rows.forEach(row => lazyLoadObserver.observe(row));
            }

            // 行を描画する関数
            function renderRow(row, year, month, weeklyTemplate, dayLabels) {
                const day = parseInt(row.dataset.dayNumber);
                const date = new Date(year, month - 1, day);
                const dayOfWeekIndex = date.getDay();
                const dayOfWeekName = dayLabels[dayOfWeekIndex];

                // 既存のセルをクリア
                const cells = row.querySelectorAll('td.drop-zone:not(.storage-location)');
                cells.forEach((cell, index) => {
                    cell.innerHTML = ''; // プレースホルダーを削除
                    cell.classList.remove('lazy-load');

                    const staffName = staffNames[index];
                    if (!staffName) return;

                    const magnetsForCell = weeklyTemplate[dayOfWeekName]?.[staffName] || [];
                    magnetsForCell.forEach(magnetData => {
                        const magnet = createMagnet(magnetData, true);
                        cell.appendChild(magnet);
                    });
                    sortMagnetsInCell(cell);

                    // 時間表示用の要素を追加
                    const timeSummary = document.createElement('div');
                    timeSummary.className = 'time-summary';
                    timeSummary.innerHTML = `
                    <span class="start-time">-</span>
                    <span class="end-time">-</span>
                    <span class="break-time">0:00</span>
                    <span class="work-time">0:00</span>
                `;
                    cell.appendChild(timeSummary);
                });

                row.dataset.rendered = 'true';

                // 遅延ロードされた行のFirebaseデータを読み込み
                loadDayDataForRow(year, month, day, row);
            }

            // 特定の日のデータを読み込む（遅延ロード用）
            async function loadDayDataForRow(year, month, day, row) {
                try {
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;
                    if (window.firebaseAPI && typeof window.firebaseAPI.loadMagnetPlacements === 'function') {
                        const placements = await window.firebaseAPI.loadMagnetPlacements(yearMonth, day, day);
                        if (placements && placements.length > 0) {
                            applyPlacementsToTable(placements, day);

                            // この行のセルの時間サマリーを更新
                            const cells = row.querySelectorAll('td.drop-zone:not(.storage-location)');
                            cells.forEach(cell => updateCellTimeSummary(cell));

                            // 担当者の合計時間を更新
                            staffNames.forEach((name, index) => {
                                updateStaffTotal(name, index);
                            });
                        }
                    }
                } catch (err) {
                    log('loadDayDataForRow エラー:', err);
                }
            }

            // マグネット配置をテーブルに適用（重複チェック付き）
            function applyPlacementsToTable(placements, targetDay = null) {
                console.log(`📥 applyPlacementsToTable: ${placements.length}件のマグネットを配置`);
                console.log('📥 配置するマグネット:', placements.map(p => ({
                    id: p.id,
                    date: p.date,
                    staff: p.staff,
                    userName: p.userName
                })));

                placements.forEach(placement => {
                    // 重複チェック: 同じIDのマグネットが既に存在する場合はスキップ
                    if (document.getElementById(placement.id)) {
                        console.log('⚠️ 重複マグネットをスキップ:', placement.id);
                        return;
                    }

                    const magnetData = {
                        id: placement.id,
                        userName: placement.userName,
                        serviceType: placement.serviceName || placement.serviceType,
                        serviceName: placement.serviceName || placement.serviceType,
                        serviceCode: placement.serviceCode || (placement.serviceType && /^[A-Za-z0-9]{6}$/.test(placement.serviceType) ? placement.serviceType : ''),
                        time: placement.time,
                        scheduledTime: placement.scheduledTime || placement.time,
                        duration: placement.durationMinutes,
                        isAccompanyStar: placement.isAccompanyStar || (placement.userName || '').startsWith('★'),
                        colorClass: placement.colorClass || '',
                        accompanyPair: placement.accompanyPair || '',
                        isCompanyBurden: placement.isCompanyBurden,
                        cancelled: placement.cancelled || false,
                        timeModified: placement.timeModified || false,
                        isNewlyCreated: placement.isNewlyCreated || false,
                        isDateChanged: placement.isDateChanged || false
                    };

                    const magnet = createMagnet(magnetData);

                    if (placement.staff === '未割り当て') {
                        unassignedBox.appendChild(magnet);
                    } else if (placement.date) {
                        const dateObj = new Date(placement.date);
                        const day = dateObj.getDate();

                        // targetDayが指定されている場合はフィルタ
                        if (targetDay !== null && day !== targetDay) return;

                        const rows = table.querySelectorAll('tbody tr');
                        for (const row of rows) {
                            const dateCell = row.querySelector('td:nth-child(2)');
                            if (!dateCell) continue;

                            const dateCellText = dateCell.textContent;
                            const dayMatch = dateCellText.match(/^(\d+)\(/);
                            if (dayMatch && parseInt(dayMatch[1]) === day) {
                                let targetCell = null;

                                if (placement.staff === '保管場所') {
                                    targetCell = row.querySelector('td:nth-child(1)');
                                } else {
                                    const staffIndex = staffNames.indexOf(placement.staff);
                                    if (staffIndex !== -1) {
                                        targetCell = row.querySelector(`td:nth-child(${staffIndex + 3})`);
                                    }
                                }

                                if (targetCell) {
                                    targetCell.appendChild(magnet);
                                    sortMagnetsInCell(targetCell);
                                    updateCellTimeSummary(targetCell);
                                }
                                break;
                            }
                        }
                    }
                });

                updateAllHours();
            }

            // 基準日までスクロール（10月は17日、その他は今日）
            function scrollToTargetDay(year, month) {
                let targetDay;
                const today = new Date();

                if (month === 10) {
                    targetDay = 17; // 10月は常に17日
                } else if (year === today.getFullYear() && month === today.getMonth() + 1) {
                    targetDay = today.getDate(); // その他の月は今日
                } else {
                    return; // 過去月・未来月はスクロールしない
                }

                const rows = table.querySelectorAll('tbody tr');

                for (const row of rows) {
                    if (parseInt(row.dataset.dayNumber) === targetDay) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // 対象の行をハイライト（3秒間）
                        row.style.backgroundColor = '#fff3cd';
                        setTimeout(() => {
                            row.style.backgroundColor = '';
                        }, 3000);
                        break;
                    }
                }
            }

            // サービスコード→略称、サービス名→略称の対応表
            // （半角英数6桁のコードは保存のみ行い、表示は略称に統一する）
            const SERVICE_CODE_ABBREVIATIONS = {
                '111000': '身体',
                '112000': '家事',
                '113000': '通有',
                '114000': '通無',
                '122000': '重Ⅱ',
                '123000': '重Ⅲ',
                '153000': '同行',
                'DK0001': '二人',
                'A11000': '移動',
                '111111': '身1',
                '111211': '身2',
                '111311': '身3',
                '111411': '身4',
                '111511': '身5',
                '111611': '身6',
                '111711': '身7',
                '111811': '身8',
                '111911': '身9',
                '117211': '生2',
                '117311': '生3',
                '114111': '身1生1',
                '114211': '身1生2',
                '114311': '身1生3',
                '115111': '身2生1',
                '115211': '身2生2',
                '115311': '身2生3',
                '116111': '身3生1',
                '116123': '身3生2',
                '116135': '身3生3',
                '116211': '身4生1',
                '116223': '身4生2',
                '116235': '身4生3',
                '116311': '身5生1',
                '116323': '身5生2',
                '116335': '身5生3',
                '116411': '身6生1',
                '116423': '身6生2',
                '116435': '身6生3',
                '116511': '身7生1',
                '116523': '身7生2',
                '116535': '身7生3',
                '116611': '身8生1',
                '116623': '身8生2',
                '116635': '身8生3',
                '116711': '身9生1',
                '116723': '身9生2',
                '116735': '身9生3',
                '114145': '身01生1',
                '114169': '身01生2',
                '114193': '身01生3',
                '114601': '身02生1',
                '114646': '身02生2',
                '114658': '身02生3',
            };

            const SERVICE_NAME_ABBREVIATIONS = {
                '障支': '障支',
                '居宅介護': '居宅',
                '居宅身体介護': '身体',
                '居宅家事援助': '家事',
                '通院介助（身体介護あり）': '通有',
                '通院介助（身体介護なし）': '通無',
                '重度訪介': '重訪',
                '重度訪問介護Ⅱ': '重Ⅱ',
                '重度訪問介護Ⅲ': '重Ⅲ',
                '同行援護': '同行',
                '2人介助（2人目）': '二人',
                '二人介助（2人目）': '二人',
                '移動支援': '移動',
                '移動支援1': '移動',
                '身体介護１': '身1',
                '身体介護1': '身1',
                '身体1生活1': '身1生1',
                '身体1生活2': '身1生2',
                '身体1生活3': '身1生3',
                '身体介護2': '身2',
                '身体2生活1': '身2生1',
                '身体2生活2': '身2生2',
                '身体2生活3': '身2生3',
                '生活援助2': '生2',
                '身体介護3': '身3',
                '身体3生活1': '身3生1',
                '身体3生活2': '身3生2',
                '身体3生活3': '身3生3',
                '身体介護4': '身4',
                '身体4生活1': '身4生1',
                '身体4生活2': '身4生2',
                '身体4生活3': '身4生3',
                '身体介護5': '身5',
                '身体5生活1': '身5生1',
                '身体5生活2': '身5生2',
                '身体5生活3': '身5生3',
                '身体介護6': '身6',
                '身体6生活1': '身6生1',
                '身体6生活2': '身6生2',
                '身体6生活3': '身6生3',
                '身体介護7': '身7',
                '身体7生活1': '身7生1',
                '身体7生活2': '身7生2',
                '身体7生活3': '身7生3',
                '身体介護8': '身8',
                '身体8生活1': '身8生1',
                '身体8生活2': '身8生2',
                '身体8生活3': '身8生3',
                '身体介護9': '身9',
                '身体9生活1': '身9生1',
                '身体9生活2': '身9生2',
                '身体9生活3': '身9生3',
                '生活援助3': '生3',
                '身体01生活1': '身01生1',
                '身体01生活2': '身01生2',
                '身体01生活3': '身01生3',
                '身体02生活1': '身02生1',
                '身体02生活2': '身02生2',
                '身体02生活3': '身02生3',
            };

            const TARGET_SERVICE_DISPLAY_UNITS = 7; // 半角3 + 全角2 に相当する幅

            function getDisplayUnits(text) {
                if (!text) return 0;
                let units = 0;
                for (const ch of text) {
                    // ASCII/半角は1、その他（日本語など全角）は2で計算
                    units += ch.charCodeAt(0) <= 0x007f ? 1 : 2;
                }
                return units;
            }

            function padAbbreviation(label) {
                if (!label) return '';
                let padded = label.trim();
                let units = getDisplayUnits(padded);
                // 最小2文字相当を満たし、最大長(3.5相当=7ユニット)にそろえる
                if (units < 2) {
                    padded = padded.padEnd(padded.length + (2 - units), '\u00A0');
                    units = getDisplayUnits(padded);
                }
                while (units < TARGET_SERVICE_DISPLAY_UNITS) {
                    padded += '\u00A0'; // NBSPで詰める（HTML上で潰れない）
                    units += 1;
                }
                return padded;
            }

            function resolveServiceAbbreviation(serviceName = '', serviceCode = '') {
                const normalizedCode = (serviceCode || '').trim().toUpperCase();
                if (normalizedCode && SERVICE_CODE_ABBREVIATIONS[normalizedCode]) {
                    return SERVICE_CODE_ABBREVIATIONS[normalizedCode];
                }

                const normalizedName = (serviceName || '').trim();
                if (normalizedName && SERVICE_NAME_ABBREVIATIONS[normalizedName]) {
                    return SERVICE_NAME_ABBREVIATIONS[normalizedName];
                }

                return normalizedName || normalizedCode;
            }

            // ========================================
            // 支給量計算機能
            // ========================================

            /**
             * サービスコードから計算ルールを判定
             * @param {string} serviceCode - サービスコード（例: "111000", "112000"）
             * @returns {string} - "30min" (30分刻み) または "15min" (15分刻み)
             */
            function getCalculationRule(serviceCode) {
                const code = (serviceCode || '').trim().toUpperCase();

                // 家事援助は15分刻み
                if (code === '112000') {
                    return '15min';
                }

                // 身体、通院（2種）、移動、二人、同行援護は30分刻み
                const thirtyMinServices = ['111000', '113000', '114000', 'A11000', 'DK0001', '153000'];
                if (thirtyMinServices.includes(code)) {
                    return '30min';
                }

                // デフォルトは30分刻み
                return '30min';
            }

            /**
             * サービス時間を支給量計算用の時間に変換
             * @param {string} timeRange - 時間範囲（例: "10:00-11:00"）
             * @param {string} serviceCode - サービスコード
             * @returns {number} - 計算後の時間（単位: 時間）
             */
            function calculateServiceHours(timeRange, serviceCode) {
                if (!timeRange || !timeRange.includes('-')) {
                    return 0;
                }

                try {
                    const [start, end] = timeRange.split('-');
                    const [startH, startM] = start.trim().split(':').map(Number);
                    const [endH, endM] = end.trim().split(':').map(Number);

                    // 所要時間を分単位で計算
                    const durationMinutes = (endH * 60 + endM) - (startH * 60 + startM);

                    if (durationMinutes <= 0) {
                        return 0;
                    }

                    const rule = getCalculationRule(serviceCode);

                    if (rule === '15min') {
                        // 家事援助: 1-30分→0.5h、その後15分刻み繰り上げ
                        if (durationMinutes <= 30) {
                            return 0.5;
                        }
                        // 31分以上は15分単位で切り上げ
                        const over30 = durationMinutes - 30;
                        const blocks15 = Math.ceil(over30 / 15);
                        return 0.5 + (blocks15 * 0.25);
                    } else {
                        // 30分刻み: 1-30分→0.5h、31-60分→1h、61-90分→1.5h
                        return Math.ceil(durationMinutes / 30) * 0.5;
                    }
                } catch (e) {
                    console.error('時間計算エラー:', e, timeRange);
                    return 0;
                }
            }

            /**
             * 総支給量計算用の時間繰り上げ処理
             * @param {number} minutes - 実際のサービス時間（分）
             * @param {string} serviceCode - サービスコード
             * @returns {number} - 繰り上げ後の時間（時間単位）
             */
            function roundUpForLimit(minutes, serviceCode) {
                // 30分刻み繰り上げ対象サービス（身体介護系）
                const roundUp30Services = ['111000', '113000', '114000', '153000', 'A11000', 'DK0001'];

                // 家事援助
                if (serviceCode === '112000') {
                    if (minutes <= 30) {
                        // 0-30分は一律30分
                        return 0.5;
                    } else {
                        // 30分超は15分単位で繰り上げ
                        const over30 = minutes - 30;
                        const roundedOver30 = Math.ceil(over30 / 15) * 15;
                        return (30 + roundedOver30) / 60;
                    }
                }

                // 30分刻み繰り上げサービス
                if (roundUp30Services.includes(serviceCode)) {
                    return Math.ceil(minutes / 30) * 30 / 60;
                }

                // その他のサービスは実時間（既存の15分繰り上げ）
                return Math.ceil(minutes / 15) * 15 / 60;
            }

            /**
             * 名前の正規化（全角・半角スペースを統一）
             * @param {string} name - 正規化する名前
             * @returns {string} - 正規化された名前（半角スペースに統一）
             */
            function normalizeName(name) {
                if (!name) return '';
                // 全角スペース(U+3000)を半角スペース(U+0020)に変換
                return name.replace(/　/g, ' ');
            }

            /**
             * 月間シフトから利用者別・サービス別の使用時間を集計（総支給量計算用）
             * @returns {Object} - { 利用者名: { サービス種類: 合計時間(h), ... }, ... }
             */
            function calculateMonthlyServiceHours() {
                const userServiceHours = {};
                const table = document.getElementById('shift-table');
                if (!table) {
                    console.log('calculateMonthlyServiceHours: テーブルが見つかりません');
                    return userServiceHours;
                }

                // すべてのマグネットを取得
                const magnets = table.querySelectorAll('.magnet');
                console.log(`calculateMonthlyServiceHours: マグネット数 = ${magnets.length}`);

                magnets.forEach(magnet => {
                    const userName = normalizeName(magnet.dataset.user); // 名前を正規化
                    let serviceCode = magnet.dataset.serviceCode;
                    const timeRange = magnet.dataset.time;

                    // 中抜けは除外
                    if (!userName || userName === '中抜け') {
                        return;
                    }

                    // 時間を分単位で取得
                    const [start, end] = timeRange.split('-');
                    const [startH, startM] = start.split(':').map(Number);
                    const [endH, endM] = end.split(':').map(Number);
                    const minutes = (endH * 60 + endM) - (startH * 60 + startM);

                    // 二人介助は身体介護としてカウント
                    let targetServiceCode = serviceCode;
                    if (serviceCode === 'DK0001') {
                        targetServiceCode = '111000'; // 身体介護の支給量にカウント
                    }

                    // 総支給量計算用の繰り上げ処理
                    const roundedHours = roundUpForLimit(minutes, serviceCode);

                    console.log(`  ${userName}: ${timeRange} (${serviceCode}) → 実時間:${minutes}分, 総支給量:${roundedHours}h ${serviceCode === 'DK0001' ? '(身体介護にカウント)' : ''}`);

                    if (roundedHours > 0) {
                        if (!userServiceHours[userName]) {
                            userServiceHours[userName] = {};
                        }
                        if (!userServiceHours[userName][targetServiceCode]) {
                            userServiceHours[userName][targetServiceCode] = 0;
                        }
                        userServiceHours[userName][targetServiceCode] += roundedHours;
                    }
                });

                console.log('月間使用時間の集計結果（総支給量計算）:', userServiceHours);
                return userServiceHours;
            }

            /**
             * サービスごとの支給量超過チェック
             * @param {Array} users - 利用者リスト（{name, serviceLimits}を含む）
             * @returns {Array} - 超過している利用者・サービスのリスト [{name, serviceType, used, limit, over}, ...]
             */
            function checkServiceLimitExceeded(users) {
                const userServiceHours = calculateMonthlyServiceHours();
                const exceeded = [];

                console.log('=== サービス別支給量チェック開始 ===');
                console.log('ユーザー数:', users.length);

                users.forEach(user => {
                    const serviceLimits = user.serviceLimits || [];
                    const normalizedUserName = normalizeName(user.name); // 名前を正規化
                    const usedServices = userServiceHours[normalizedUserName] || {};

                    console.log(`[${user.name}] サービス支給量:`, serviceLimits);
                    console.log(`[${user.name}] 使用状況:`, usedServices);

                    // 各サービスの支給量をチェック
                    serviceLimits.forEach(serviceLimit => {
                        const serviceType = serviceLimit.type;
                        const limit = parseFloat(serviceLimit.monthlyLimit) || 0;
                        const used = usedServices[serviceType] || 0;

                        console.log(`  [${serviceType}] 使用: ${used}h, 支給量: ${limit}h, 超過: ${used > limit ? 'YES' : 'NO'}`);

                        // 支給量が設定されていて、かつ超過している場合
                        if (limit > 0 && used > limit) {
                            exceeded.push({
                                name: user.name,
                                serviceType: serviceType,
                                used: used,
                                limit: limit,
                                over: used - limit
                            });
                        }
                    });
                });

                console.log('超過件数:', exceeded.length);
                console.log('=== サービス別支給量チェック終了 ===');

                return exceeded.sort((a, b) => b.over - a.over); // 超過量の多い順
            }

            function buildMagnetInnerHTML({
                userName = '',
                customServiceName = '',
                serviceDisplay = '',
                serviceCode = '',
                time = '',
                resolvedAbbr = '',
                isAccompanyStar = false,
                markerHtml = ''
            } = {}) {
                const hasStarPrefix = userName.startsWith('★');
                const shouldShowStar = isAccompanyStar || hasStarPrefix;
                const userNameWithoutStar = userName.replace(/^★/, '');
                const abbr = resolvedAbbr || resolveServiceAbbreviation(serviceDisplay, serviceCode) || serviceDisplay;
                const marker = markerHtml || '';

                if (userName === '中抜け') {
                    // 中抜けは特別扱い：「中抜け」と時間のみ表示
                    return `
                        <span class="magnet-name">中抜け${marker}</span>
                        <span class="magnet-time">${time || ''}</span>
                    `.trim();
                }

                // 一列表示: 利用者名 → カスタムサービス名 → サービス名 → ★（同行時のみ） → 時間
                const userHtml = `<span class="magnet-name">${userNameWithoutStar}${marker}</span>`;
                const customServiceHtml = customServiceName ? `<span class="magnet-custom-service">${customServiceName}</span>` : '';
                const serviceHtml = abbr ? `<span class="magnet-service">${abbr}</span>` : '';
                const starHtml = shouldShowStar ? '<span class="magnet-star">★</span>' : '';
                const timeHtml = `<span class="magnet-time">${time || ''}</span>`;

                return `${userHtml}${customServiceHtml}${serviceHtml}${starHtml}${timeHtml}`.trim();
            }

            function magnetHasAccompanyStar(magnet) {
                if (!magnet) return false;
                return magnet.dataset.isAccompanyStar === 'true' || (magnet.dataset.user || '').startsWith('★');
            }

            function getMagnetColorClass(magnet) {
                if (!magnet) return '';
                return magnet.dataset.colorClass || Array.from(magnet.classList).find(cls => cls.startsWith('color-')) || '';
            }

            function applyColorClass(magnet, colorClass) {
                if (!magnet) return;
                Array.from(magnet.classList)
                    .filter(cls => cls.startsWith('color-'))
                    .forEach(cls => magnet.classList.remove(cls));
                if (colorClass) {
                    magnet.classList.add(colorClass);
                    magnet.dataset.colorClass = colorClass;
                } else {
                    delete magnet.dataset.colorClass;
                }
            }

            function createMagnet(data, isTemplate = false) {
                const magnet = document.createElement('div');
                magnet.draggable = true;
                let userName, customServiceName, serviceType, serviceName, serviceCode, time;

                if (isTemplate) {
                    magnet.id = `magnet-tpl-${Date.now()}-${Math.random()}`;
                    const parts = data.text.split(' ');
                    if (parts.length >= 3) {
                        time = parts.pop();
                        serviceType = parts.pop();
                        userName = parts.join(' ');
                    } else {
                        userName = parts[0] || '';
                        serviceType = parts[1] || '';
                        time = parts[2] || '';
                    }
                    customServiceName = data.customServiceName || '';
                    serviceName = data.serviceName || serviceType || '';
                    serviceCode = data.serviceCode || '';
                } else {
                    magnet.id = data.id;
                    userName = data.userName || '';
                    customServiceName = data.customServiceName || '';
                    serviceType = data.serviceType || '';
                    serviceName = data.serviceName || serviceType || '';
                    serviceCode = data.serviceCode || '';
                    time = data.time || '';
                    log('createMagnet - データ:', { userName, customServiceName, serviceType, serviceName, serviceCode, time, isTemplate });
                }

                // 6文字のサービスコードを分離
                const displayService = serviceName || (serviceType && !/^[A-Za-z0-9]{6}$/.test(serviceType) ? serviceType : '');
                const normalizedServiceCode = serviceCode || (/^[A-Za-z0-9]{6}$/.test(serviceType) ? serviceType : '');
                const resolvedAbbr = resolveServiceAbbreviation(displayService, normalizedServiceCode);

                const isAccompanyStar = Boolean(data.isAccompanyStar) || (userName || '').startsWith('★');
                magnet.innerHTML = buildMagnetInnerHTML({
                    userName,
                    customServiceName,
                    serviceDisplay: displayService,
                    serviceCode: normalizedServiceCode,
                    time,
                    resolvedAbbr,
                    isAccompanyStar
                });
                magnet.className = 'magnet';
                magnet.dataset.user = userName;
                magnet.dataset.customServiceName = customServiceName || '';
                magnet.dataset.service = resolvedAbbr || displayService;
                magnet.dataset.serviceAbbr = resolvedAbbr || displayService;
                magnet.dataset.serviceName = serviceName || displayService;
                magnet.dataset.serviceCode = normalizedServiceCode;
                magnet.dataset.time = time;
                magnet.dataset.scheduledTime = data.scheduledTime || time; // 予定時刻
                magnet.dataset.isAccompanyStar = isAccompanyStar ? 'true' : 'false';
                if (data.accompanyPair) {
                    magnet.dataset.accompanyPair = data.accompanyPair;
                }
                // 同行（isAccompany）の場合は黄色にする
                if (data.isAccompany) {
                    magnet.classList.add('color-yellow');
                    magnet.dataset.isAccompany = 'true';
                }

                const initialColorClass = data.colorClass || '';
                if (initialColorClass) {
                    applyColorClass(magnet, initialColorClass);
                }
                // 同行マーク付きマグネットの場合、複製元のスタッフ情報を保持
                if (data.isAccompanyStar && data.companionOriginalStaff) {
                    magnet.dataset.companionOriginalStaff = data.companionOriginalStaff;
                }

                let serviceClass = 'service-type-その他';
                const serviceText = resolvedAbbr || displayService || '';
                if (serviceText.includes('身')) serviceClass = 'service-type-身';
                else if (serviceText.includes('生')) serviceClass = 'service-type-生';
                else if (serviceText.includes('家')) serviceClass = 'service-type-家';
                else if (serviceText.includes('移')) serviceClass = 'service-type-移';
                else if (serviceText.includes('居')) serviceClass = 'service-type-居';
                magnet.classList.add(serviceClass);


                try {
                    const timeStr = time;
                    if (timeStr && timeStr.includes('-')) {
                        const [start, end] = timeStr.split('-').map(t => t.split(':'));
                        const durationMinutes = (new Date(0, 0, 0, end[0], end[1]) - new Date(0, 0, 0, start[0], start[1])) / 60000;
                        magnet.dataset.durationMinutes = durationMinutes;
                    } else {
                        magnet.dataset.durationMinutes = data.duration || 0;
                    }
                } catch (e) {
                    magnet.dataset.durationMinutes = data.duration || 0;
                }

                // 会社負担マークの追加 + 紫色スタイル
                if (data.isCompanyBurden) {
                    magnet.classList.add('company-burden');
                    magnet.style.backgroundColor = '#9370db';
                    magnet.style.color = 'white';
                    // 子要素の色も白に
                    setTimeout(() => {
                        const parts = magnet.querySelectorAll('.magnet-name, .magnet-service, .magnet-time');
                        parts.forEach(p => p.style.color = 'white');
                    }, 0);
                }

                // キャンセル（赤色）
                if (data.cancelled) {
                    magnet.dataset.cancelled = 'true';
                    magnet.dataset.colorClass = magnet.dataset.colorClass || 'color-red';
                    magnet.classList.add('color-red');
                    magnet.classList.add('magnet-cancelled');
                }

                // 時間変更（オレンジ）
                if (data.timeModified) {
                    magnet.dataset.timeModified = 'true';
                    if (!magnet.dataset.colorClass) {
                        magnet.dataset.colorClass = 'color-orange';
                    }
                    magnet.classList.add('color-orange');
                    magnet.classList.add('magnet-time-modified');
                }

                // 日付変更マーク
                if (data.isDateChanged) {
                    magnet.classList.add('date-changed');
                }

                return magnet;
            }
            // 既存のマグネットの構造を修正する関数（最適化: 描画済みの行のみ処理）
            function fixExistingMagnetStructure() {
                // 描画済みの行のマグネットのみ処理してフリーズを防止
                const renderedRows = document.querySelectorAll('#shift-table tbody tr[data-rendered="true"]');
                renderedRows.forEach(row => {
                    const magnets = row.querySelectorAll('.magnet');
                    magnets.forEach(magnet => {
                        // 既に新しい構造になっているかチェック
                        if (magnet.querySelector('.magnet-name') && magnet.querySelector('.magnet-service') && magnet.querySelector('.magnet-time')) {
                            return; // 既に修正済み
                        }

                        // 古い構造のマグネットを修正
                        const userName = magnet.dataset.user || '';
                        const serviceType = magnet.dataset.service || '';
                        const serviceCode = magnet.dataset.serviceCode || '';
                        const resolvedAbbr = resolveServiceAbbreviation(serviceType, serviceCode);
                        const time = magnet.dataset.time || '';
                        const isAccompanyStar = magnetHasAccompanyStar(magnet);

                        // 新しいHTML構造に変更
                        magnet.innerHTML = buildMagnetInnerHTML({
                            userName,
                            serviceDisplay: resolvedAbbr || serviceType,
                            serviceCode,
                            time,
                            resolvedAbbr,
                            isAccompanyStar
                        });
                        magnet.dataset.isAccompanyStar = isAccompanyStar ? 'true' : 'false';
                        magnet.dataset.service = resolvedAbbr || serviceType;
                        magnet.dataset.serviceAbbr = resolvedAbbr || serviceType;
                    });
                });

                // 未割り当てBOXのマグネットも処理
                const unassignedMagnets = document.querySelectorAll('#unassigned-box .magnet');
                unassignedMagnets.forEach(magnet => {
                    if (magnet.querySelector('.magnet-name') && magnet.querySelector('.magnet-service') && magnet.querySelector('.magnet-time')) {
                        return;
                    }
                    const userName = magnet.dataset.user || '';
                    const serviceType = magnet.dataset.service || '';
                    const serviceCode = magnet.dataset.serviceCode || '';
                    const resolvedAbbr = resolveServiceAbbreviation(serviceType, serviceCode);
                    const time = magnet.dataset.time || '';
                    const isAccompanyStar = magnetHasAccompanyStar(magnet);
                    magnet.innerHTML = buildMagnetInnerHTML({
                        userName,
                        serviceDisplay: resolvedAbbr || serviceType,
                        serviceCode,
                        time,
                        resolvedAbbr,
                        isAccompanyStar
                    });
                    magnet.dataset.isAccompanyStar = isAccompanyStar ? 'true' : 'false';
                    magnet.dataset.service = resolvedAbbr || serviceType;
                    magnet.dataset.serviceAbbr = resolvedAbbr || serviceType;
                });
            }

            // 最適化版: マグネット挿入時に二分探索で適切な位置に挿入（全ソート不要）
            function sortMagnetsInCell(cell, newMagnet = null) {
                const getStartTime = (magnet) => {
                    const timeMatch = magnet.dataset.time.match(/(\d{2}:\d{2})/);
                    return timeMatch ? timeMatch[1] : '23:59';
                };

                // 新規マグネットが指定されている場合は二分探索で挿入
                if (newMagnet && newMagnet.parentElement === cell) {
                    const magnets = Array.from(cell.querySelectorAll('.magnet'));
                    const targetTime = getStartTime(newMagnet);

                    // 二分探索で挿入位置を見つける
                    let left = 0;
                    let right = magnets.length - 1;
                    let insertIndex = magnets.length;

                    while (left <= right) {
                        const mid = Math.floor((left + right) / 2);
                        const midTime = getStartTime(magnets[mid]);

                        if (midTime > targetTime) {
                            insertIndex = mid;
                            right = mid - 1;
                        } else {
                            left = mid + 1;
                        }
                    }

                    // 適切な位置に挿入
                    if (insertIndex < magnets.length) {
                        cell.insertBefore(newMagnet, magnets[insertIndex]);
                    } else {
                        // 最後に time-summary があるので、その前に挿入
                        const timeSummary = cell.querySelector('.time-summary');
                        if (timeSummary) {
                            cell.insertBefore(newMagnet, timeSummary);
                        } else {
                            cell.appendChild(newMagnet);
                        }
                    }
                } else {
                    // 従来の全ソート（初期表示時など）
                    const magnets = Array.from(cell.querySelectorAll('.magnet'));
                    magnets.sort((a, b) => getStartTime(a).localeCompare(getStartTime(b)));
                    const timeSummary = cell.querySelector('.time-summary');
                    magnets.forEach(magnet => {
                        if (timeSummary) {
                            cell.insertBefore(magnet, timeSummary);
                        } else {
                            cell.appendChild(magnet);
                        }
                    });
                }
            }

            // 仮想スクロール用のデータ同期関数（スタブ）
            // 注: この関数は過去の仮想スクロール機能の名残です。現在は使用されていません。
            function syncCellToAllDaysData(cell) {
                // 何もしない（互換性のために残している）
                return;
            }

            // ========================================
            // 変更連絡一覧機能
            // ========================================

            // 変更連絡をFirestoreに保存する関数
            async function saveChangeNotification(changeData) {
                try {
                    const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

                    if (window.firebaseAPI && db) {
                        const { collection, addDoc, serverTimestamp } = window.firebaseModules;
                        const notificationsRef = collection(db, 'changeNotifications', yearMonth, 'notifications');

                        const notification = {
                            userName: changeData.userName || '',
                            date: changeData.date || '',
                            changeType: changeData.changeType || '', // '新規追加' | '曜日間移動' | '時間変更' | 'キャンセル'
                            staffName: changeData.staffName || '',
                            serviceName: changeData.serviceName || '',
                            details: changeData.details || '',
                            time: changeData.time || '',
                            timestamp: serverTimestamp(),
                            createdAt: new Date().toISOString()
                        };

                        await addDoc(notificationsRef, notification);
                        console.log('📝 変更連絡を記録:', notification);
                    }
                } catch (error) {
                    console.error('❌ 変更連絡の保存エラー:', error);
                }
            }

            // ========================================
            // リアルタイム同期: 自動保存関数
            // ========================================

            let realtimeUnsubscribe = null;
            let isUpdatingFromRemote = false; // 無限ループ防止フラグ
            let autoSaveTimeout = null;
            let isDragging = false; // ドラッグ中フラグ（連続ドラッグ時の保存抑制用）
            let lazyLoadObserver = null; // IntersectionObserver のグローバル参照（メモリリーク防止）
            let autoScrollInterval = null; // ドラッグ中の自動スクロール用タイマー

            // デバウンス付き自動保存関数（変更があった日のみ保存、1.5秒デバウンス）
            async function autoSaveMagnetPlacement(changedDay) {
                console.log(`💾 自動保存トリガー: ${changedDay}日`);
                if (isUpdatingFromRemote) {
                    console.log('⏸️ リモート更新中のため保存をスキップ');
                    return; // リモート更新中は保存しない
                }

                clearTimeout(autoSaveTimeout);
                autoSaveTimeout = setTimeout(async () => {
                    // ドラッグ中の場合は保存を延期
                    if (isDragging) {
                        console.log('⏸️ ドラッグ中のため保存を延期');
                        autoSaveMagnetPlacement(changedDay); // 再度デバウンスをかける
                        return;
                    }
                    try {
                        console.log(`📤 自動保存実行開始: ${changedDay}日`);
                        updateAutoSaveIndicator('saving');
                        const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

                        // 変更があった日のマグネット配置のみを収集
                        const placements = [];

                        if (changedDay === 'unassigned') {
                            // 未割り当てBOXの場合
                            const unassignedMagnets = unassignedBox.querySelectorAll('.magnet');
                            unassignedMagnets.forEach(magnet => {
                                const colorClass = getMagnetColorClass(magnet);
                                const accompanyPair = magnet.dataset.accompanyPair || '';
                                placements.push({
                                    id: magnet.id,
                                    date: null,
                                    staff: '未割り当て',
                                    userName: magnet.dataset.user,
                                    serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                                    serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                                    serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                                    time: magnet.dataset.time,
                                    durationMinutes: magnet.dataset.durationMinutes,
                                    isAccompanyStar: magnetHasAccompanyStar(magnet),
                                    colorClass,
                                    accompanyPair,
                                    isCompanyBurden: magnet.classList.contains('company-burden'),
                                    isNewlyCreated: magnet.classList.contains('newly-created'),
                                    isDateChanged: magnet.classList.contains('date-changed')
                                });
                            });
                        } else {
                            // 特定の日の場合
                            const rows = table.querySelectorAll('tbody tr');
                            for (const row of rows) {
                                const dateCell = row.querySelector('td:nth-child(2)');
                                if (!dateCell) continue;

                                const dateCellText = dateCell.textContent;
                                const dayMatch = dateCellText.match(/^(\d+)\(/);
                                if (!dayMatch || parseInt(dayMatch[1]) !== changedDay) continue;

                                const day = parseInt(dayMatch[1]);
                                const year = currentDate.getFullYear();
                                const month = currentDate.getMonth() + 1;
                                const date = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                                // 各担当者のセルを確認
                                staffNames.forEach((staffName, index) => {
                                    const cell = row.querySelector(`td:nth-child(${index + 3})`);
                                    if (!cell) return;

                                    const magnets = cell.querySelectorAll('.magnet');
                                    magnets.forEach(magnet => {
                                        const hasDateChanged = magnet.classList.contains('date-changed');
                                        const hasNewlyCreated = magnet.classList.contains('newly-created');
                                        const colorClass = getMagnetColorClass(magnet);
                                        const accompanyPair = magnet.dataset.accompanyPair || '';

                                        placements.push({
                                            id: magnet.id,
                                            date: date,
                                            staff: staffName,
                                            userName: magnet.dataset.user,
                                            serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                                            serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                                            serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                                            time: magnet.dataset.time,
                                            durationMinutes: magnet.dataset.durationMinutes,
                                            isAccompanyStar: magnetHasAccompanyStar(magnet),
                                            colorClass,
                                            accompanyPair,
                                            isCompanyBurden: magnet.classList.contains('company-burden'),
                                            isNewlyCreated: hasNewlyCreated,
                                            isDateChanged: hasDateChanged
                                        });

                                        if (hasDateChanged || hasNewlyCreated) {
                                            console.log('💾 保存データ:', {
                                                userName: magnet.dataset.user,
                                                isNewlyCreated: hasNewlyCreated,
                                                isDateChanged: hasDateChanged,
                                                allClasses: Array.from(magnet.classList)
                                            });
                                        }
                                    });
                                });

                                // 保管場所のセルも確認
                                const storageCell = row.querySelector('td:nth-child(1)');
                                if (storageCell) {
                                    const magnets = storageCell.querySelectorAll('.magnet');
                                    magnets.forEach(magnet => {
                                        const colorClass = getMagnetColorClass(magnet);
                                        const accompanyPair = magnet.dataset.accompanyPair || '';
                                        placements.push({
                                            id: magnet.id,
                                            date: date,
                                            staff: '保管場所',
                                            userName: magnet.dataset.user,
                                            serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                                            serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                                            serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                                            time: magnet.dataset.time,
                                            durationMinutes: magnet.dataset.durationMinutes,
                                            isAccompanyStar: magnetHasAccompanyStar(magnet),
                                            colorClass,
                                            accompanyPair,
                                            isCompanyBurden: magnet.classList.contains('company-burden'),
                                            isNewlyCreated: magnet.classList.contains('newly-created'),
                                            isDateChanged: magnet.classList.contains('date-changed')
                                        });
                                    });
                                }
                                break;
                            }
                        }

                        // Firestoreに保存（該当日のみ）
                        if (window.firebaseAPI && db) {
                            const { doc, setDoc } = window.firestoreUtils;
                            const dayStr = changedDay === 'unassigned' ? 'unassigned' : String(changedDay).padStart(2, '0');
                            const dayDocRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'days', dayStr);

                            console.log(`📝 保存するデータ (${dayStr}日):`, placements.map(p => ({
                                id: p.id,
                                date: p.date,
                                staff: p.staff,
                                userName: p.userName,
                                time: p.time
                            })));

                            await setDoc(dayDocRef, {
                                placements: placements,
                                updatedAt: new Date().toISOString()
                            });
                            console.log(`✅ 自動保存完了 (magnetPlacements): ${yearMonth} ${dayStr}日 (${placements.length}件)`);
                            console.log(`📍 保存先パス: ${MAGNET_PLACEMENTS}/${yearMonth}/days/${dayStr}`);
                            log(`✓ 自動保存完了: ${yearMonth} ${dayStr}日 (${placements.length}件)`);

                            // shiftsコレクションにも保存（サービス報告アプリ用）
                            if (changedDay !== 'unassigned' && typeof window.firebaseAPI.saveShift === 'function') {
                                let savedShiftCount = 0;
                                for (const placement of placements) {
                                    // 未割り当てや保管場所はスキップ
                                    if (!placement.date || placement.staff === '未割り当て' || placement.staff === '保管場所') {
                                        continue;
                                    }

                                    // 時間を分割
                                    const timeMatch = placement.time.match(/(\d{2}:\d{2})-(\d{2}:\d{2})/);
                                    if (!timeMatch) continue;

                                    const shift = {
                                        staff: placement.staff,
                                        userName: placement.userName,
                                        customerName: placement.userName,
                                        serviceType: placement.serviceType,
                                        startTime: timeMatch[1],
                                        endTime: timeMatch[2],
                                        time: placement.time,
                                        date: placement.date,
                                        createdAt: new Date().toISOString(),
                                        helperUid: ''
                                    };

                                    try {
                                        await window.firebaseAPI.saveShift(shift);
                                        savedShiftCount++;
                                    } catch (shiftErr) {
                                        console.error('シフト自動保存エラー:', shiftErr);
                                    }
                                }
                                console.log(`✅ シフト自動保存完了: ${savedShiftCount}件`);
                            }
                            updateAutoSaveIndicator('saved');
                        } else {
                            console.warn('⚠️ Firebase未初期化のため保存できません');
                            updateAutoSaveIndicator('error');
                        }
                    } catch (error) {
                        console.error('❌ 自動保存エラー:', error);
                        updateAutoSaveIndicator('error');
                    }
                }, 1500); // 1.5秒デバウンス（パフォーマンス改善）
            }

            // セルの状態（公休・有給・特休）を保存する関数
            let autoSaveCellTimeout;
            async function autoSaveCellStates() {
                clearTimeout(autoSaveCellTimeout);
                autoSaveCellTimeout = setTimeout(async () => {
                    try {
                        console.log('💾 セル状態の保存を開始...');
                        const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;
                        const cellStates = {};
                        console.log('💾 保存先:', yearMonth);

                        // 全てのセルの状態を収集
                        document.querySelectorAll('#shift-table tbody tr:not(.week-summary-row)').forEach(row => {
                            const dateCell = row.querySelector('td:nth-child(2)');
                            if (!dateCell) return;

                            const dateCellText = dateCell.textContent;
                            const dayMatch = dateCellText.match(/^(\d+)\(/);
                            if (!dayMatch) return;

                            const day = parseInt(dayMatch[1]);
                            const year = currentDate.getFullYear();
                            const month = currentDate.getMonth() + 1;
                            const date = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                            staffNames.forEach((staffName, index) => {
                                const cell = row.querySelector(`td:nth-child(${index + 3})`);
                                if (!cell) return;

                                let cellType = null;
                                if (cell.classList.contains('cell-koukyu')) {
                                    cellType = 'koukyu';
                                } else if (cell.classList.contains('cell-yuukyu')) {
                                    cellType = 'yuukyu';
                                } else if (cell.classList.contains('cell-tokkyu')) {
                                    cellType = 'tokkyu';
                                }

                                if (cellType) {
                                    if (!cellStates[date]) {
                                        cellStates[date] = {};
                                    }
                                    cellStates[date][staffName] = cellType;
                                }
                            });
                        });

                        // Firebaseに保存（magnet_placementsコレクションに保存）
                        console.log('💾 保存するデータ:', cellStates);
                        if (db) {
                            const { doc, setDoc } = window.firestoreUtils;
                            // magnet_placements/YYYY-MM/cell_states/data に保存
                            const cellStatesRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'cell_states', 'data');
                            await setDoc(cellStatesRef, { states: cellStates });
                            console.log('✅ セル状態を保存しました:', yearMonth, cellStates);
                        } else {
                            console.error('❌ Firebaseが初期化されていません');
                        }
                    } catch (err) {
                        console.error('❌ セル状態保存エラー:', err);
                    }
                }, 500);
            }

            // イベント委譲: 全てのドラッグ&ドロップイベントを document で一元管理（パフォーマンス改善）
            let dragEventsInitialized = false;
            let currentDragOverZone = null; // drag-over 状態管理用

            function setupDragAndDrop() {
                // イベント委譲は一度だけ設定（重複登録を防ぐ）
                if (!dragEventsInitialized) {
                    // dragstart: document で監視
                    document.addEventListener('dragstart', e => {
                        if (e.target.classList.contains('magnet')) {
                            isDragging = true; // ドラッグ開始
                            cancelCut();
                            draggedMagnet = e.target;
                            draggedMagnet.classList.add('dragging'); // ドラッグ中のスタイルを適用

                            const originCell = draggedMagnet.parentElement;
                            const dateCell = originCell.closest('tr')?.querySelector('td:nth-child(2)');
                            moveOriginInfo = {
                                from: getLocationName(originCell),
                                date: dateCell ? dateCell.textContent : '未割り当てBOX'
                            };

                            // ドラッグ開始時に状態を保存
                            saveStateToUndo();
                        }
                    });

                    // dragover: document で監視し、drop-zone を動的に判定
                    document.addEventListener('dragover', e => {
                        if (!draggedMagnet) return;

                        const dropTarget = e.target.closest('.drop-zone');
                        if (dropTarget) {
                            e.preventDefault(); // ドロップ可能にする

                            // drag-over 状態を更新（変更があった場合のみ）
                            if (currentDragOverZone !== dropTarget) {
                                if (currentDragOverZone) {
                                    currentDragOverZone.classList.remove('drag-over');
                                }
                                dropTarget.classList.add('drag-over');
                                currentDragOverZone = dropTarget;
                            }
                        }

                        // ドラッグ中の自動スクロール機能
                        const container = document.getElementById('shift-table-container');
                        if (container) {
                            const rect = container.getBoundingClientRect();
                            const scrollSpeed = 10;
                            const edgeSize = 50; // 端から50pxの範囲で自動スクロール

                            // 自動スクロールを停止
                            if (autoScrollInterval) {
                                clearInterval(autoScrollInterval);
                                autoScrollInterval = null;
                            }

                            // 上端に近い場合は上にスクロール
                            if (e.clientY - rect.top < edgeSize) {
                                autoScrollInterval = setInterval(() => {
                                    container.scrollTop -= scrollSpeed;
                                }, 50);
                            }
                            // 下端に近い場合は下にスクロール
                            else if (rect.bottom - e.clientY < edgeSize) {
                                autoScrollInterval = setInterval(() => {
                                    container.scrollTop += scrollSpeed;
                                }, 50);
                            }
                            // 左端に近い場合は左にスクロール
                            else if (e.clientX - rect.left < edgeSize) {
                                autoScrollInterval = setInterval(() => {
                                    container.scrollLeft -= scrollSpeed;
                                }, 50);
                            }
                            // 右端に近い場合は右にスクロール
                            else if (rect.right - e.clientX < edgeSize) {
                                autoScrollInterval = setInterval(() => {
                                    container.scrollLeft += scrollSpeed;
                                }, 50);
                            }
                        }
                    });

                    // dragleave: document で監視
                    document.addEventListener('dragleave', e => {
                        if (!draggedMagnet) return;

                        // ドキュメント外に出た場合のみ drag-over を削除
                        if (e.target === document.documentElement) {
                            if (currentDragOverZone) {
                                currentDragOverZone.classList.remove('drag-over');
                                currentDragOverZone = null;
                            }
                        }
                    });

                    // drop: document で監視
                    document.addEventListener('drop', e => {
                        if (!draggedMagnet) return;

                        e.preventDefault();
                        const dropTarget = e.target.closest('.drop-zone');

                        if (dropTarget) {
                            const originCell = draggedMagnet.parentElement; // 移動元のセルを保存
                            const to = getLocationName(dropTarget);
                            const from = moveOriginInfo ? moveOriginInfo.from : '不明';

                            console.log('🔍 ドロップ時の情報:', {
                                moveOriginInfo: moveOriginInfo,
                                from: from,
                                to: to,
                                draggedMagnetId: draggedMagnet.id
                            });

                            // 移動先の日付を取得
                            let toDate = '未割り当てBOX';
                            if (dropTarget.id !== 'unassigned-box') {
                                const toRow = dropTarget.closest('tr');
                                if (toRow) {
                                    const toDateCell = toRow.querySelector('td:nth-child(2)');
                                    if (toDateCell) {
                                        toDate = toDateCell.textContent;
                                        console.log('📅 移動先の日付を取得:', toDate, 'from cell:', toDateCell);
                                    }
                                }
                            }
                            console.log('📅 移動先日付の最終値:', toDate);

                            // 移動元の日付を保存（自動保存用）
                            let originDay = null;
                            if (moveOriginInfo) {
                                if (moveOriginInfo.date === '未割り当てBOX') {
                                    originDay = 'unassigned';
                                } else {
                                    const dayMatch = moveOriginInfo.date.match(/^(\d+)\(/);
                                    if (dayMatch) {
                                        originDay = parseInt(dayMatch[1]);
                                    }
                                }
                            }

                            // 移動元と移動先が異なる場合（担当者が異なる OR 日付が異なる）のみ確認ダイアログを表示
                            const fromDate = moveOriginInfo ? moveOriginInfo.date : '';
                            const locationChanged = moveOriginInfo && (moveOriginInfo.from !== to || fromDate !== toDate);

                            // 日付が変更されたかどうかを判定（より厳密なチェック）
                            let dateChanged = false;
                            if (moveOriginInfo && fromDate && toDate) {
                                // 空白や改行を削除して比較
                                const cleanFromDate = String(fromDate).trim();
                                const cleanToDate = String(toDate).trim();
                                dateChanged = cleanFromDate !== cleanToDate;

                                console.log('🔍 日付変更判定:', {
                                    fromDate: fromDate,
                                    toDate: toDate,
                                    cleanFromDate: cleanFromDate,
                                    cleanToDate: cleanToDate,
                                    dateChanged: dateChanged,
                                    comparison: `"${cleanFromDate}" !== "${cleanToDate}" = ${cleanFromDate !== cleanToDate}`,
                                    moveOriginInfoExists: !!moveOriginInfo,
                                    draggedMagnetId: draggedMagnet?.id
                                });
                            } else {
                                console.log('🔍 日付変更判定スキップ:', {
                                    moveOriginInfo: moveOriginInfo,
                                    fromDate: fromDate,
                                    toDate: toDate,
                                    reason: !moveOriginInfo ? 'moveOriginInfo が null' : (!fromDate ? 'fromDate が空' : 'toDate が空')
                                });
                            }

                            if (locationChanged) {
                                const magnetUser = draggedMagnet.dataset.user;
                                const magnetTime = draggedMagnet.dataset.time;

                                // メッセージを日付を含めて表示
                                let fromText = `${from}（${fromDate}）`;
                                let toText = `${to}（${toDate}）`;

                                const message = `「${magnetUser} ${magnetTime}」のシフトを\n「${fromText}」から「${toText}」に移動させます。\n\nよろしいですか？`;

                                if (!confirm(message)) {
                                    // キャンセルされた場合はドラッグをキャンセル
                                    if (currentDragOverZone) {
                                        currentDragOverZone.classList.remove('drag-over');
                                        currentDragOverZone = null;
                                    }
                                    isDragging = false;
                                    if (draggedMagnet) {
                                        draggedMagnet.classList.remove('dragging');
                                        draggedMagnet = null;
                                    }
                                    if (autoScrollInterval) {
                                        clearInterval(autoScrollInterval);
                                        autoScrollInterval = null;
                                    }
                                    moveOriginInfo = null;
                                    return;
                                }

                                addHistoryEntry(draggedMagnet.innerHTML, fromText, toText, moveOriginInfo.date);
                            }
                            moveOriginInfo = null;

                            dropTarget.classList.remove('drag-over');
                            dropTarget.appendChild(draggedMagnet);

                            // 日付が変更された場合、date-changedクラスを追加
                            if (dateChanged) {
                                // newly-createdクラスがある場合は削除（日付変更の方が優先）
                                draggedMagnet.classList.remove('newly-created');
                                draggedMagnet.classList.add('date-changed');
                                console.log('✅ 日付変更クラス追加:', draggedMagnet.classList.contains('date-changed'), draggedMagnet);

                                // マグネットのHTMLを更新して[移動]マーカーを追加
                                const userName = draggedMagnet.dataset.user;
                                const serviceType = draggedMagnet.dataset.service;
                                const serviceCode = draggedMagnet.dataset.serviceCode || '';
                                const time = draggedMagnet.dataset.time;
                                const resolvedAbbr = resolveServiceAbbreviation(draggedMagnet.dataset.serviceName || serviceType, serviceCode) || serviceType;
                                const markerText = '<span style="background:#2196F3;color:white;padding:1px 4px;border-radius:2px;font-size:9px;margin-left:3px;font-weight:bold;">[移動]</span>';
                                const isAccompanyStar = magnetHasAccompanyStar(draggedMagnet);

                                draggedMagnet.innerHTML = buildMagnetInnerHTML({
                                    userName,
                                    serviceDisplay: resolvedAbbr,
                                    serviceCode,
                                    time,
                                    resolvedAbbr,
                                    isAccompanyStar,
                                    markerHtml: markerText
                                });
                                draggedMagnet.dataset.isAccompanyStar = isAccompanyStar ? 'true' : 'false';
                                console.log('🔵 [移動]マーカーを追加しました:', userName);

                                // 変更連絡を記録（曜日間移動）
                                // 移動先の日付を取得
                                let movedToDate = '';
                                if (dropTarget.id !== 'unassigned-box') {
                                    const toRow = dropTarget.closest('tr');
                                    if (toRow) {
                                        const toDateCell = toRow.querySelector('td:nth-child(2)');
                                        if (toDateCell) {
                                            const dayMatch = toDateCell.textContent.match(/^(\d+)\(/);
                                            if (dayMatch) {
                                                const day = parseInt(dayMatch[1]);
                                                const year = currentDate.getFullYear();
                                                const month = currentDate.getMonth() + 1;
                                                movedToDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                                            }
                                        }
                                    }
                                }

                                // 移動先の担当者を取得
                                let movedToStaff = to;

                                saveChangeNotification({
                                    userName: userName,
                                    date: movedToDate || new Date().toISOString().split('T')[0],
                                    changeType: '曜日間移動',
                                    staffName: movedToStaff,
                                    serviceName: serviceType,
                                    details: `${fromDate} → ${toDate} に移動`,
                                    time: time
                                });
                            }

                            sortMagnetsInCell(dropTarget);

                            // 部分更新: 影響したセルと担当者のみ更新
                            updateCellTimeSummary(dropTarget);

                            // 移動元のセルも更新（未割り当てBOXでない場合）
                            if (originCell && originCell.id !== 'unassigned-box') {
                                updateCellTimeSummary(originCell);
                            }

                            // 担当者の合計時間を部分更新（テーブルのセルの場合のみ）
                            if (dropTarget.id !== 'unassigned-box') {
                                const dropRow = dropTarget.closest('tr');
                                if (dropRow) {
                                    const dropCells = Array.from(dropRow.querySelectorAll('td.drop-zone:not(.storage-location)'));
                                    const dropIndex = dropCells.indexOf(dropTarget);
                                    if (dropIndex !== -1 && staffNames[dropIndex]) {
                                        updateStaffTotal(staffNames[dropIndex], dropIndex);
                                    }
                                }
                            }
                            if (originCell && originCell.id !== 'unassigned-box') {
                                const originRow = originCell.closest('tr');
                                if (originRow) {
                                    const originCells = Array.from(originRow.querySelectorAll('td.drop-zone:not(.storage-location)'));
                                    const originIndex = originCells.indexOf(originCell);
                                    if (originIndex !== -1 && staffNames[originIndex]) {
                                        updateStaffTotal(staffNames[originIndex], originIndex);
                                    }
                                }
                            }

                            // 自動保存: ドロップ先のセルから日付を取得
                            let changedDay = null;

                            // 未割り当てBOXの場合
                            if (dropTarget.id === 'unassigned-box') {
                                changedDay = 'unassigned';
                            } else {
                                // テーブルのセルの場合
                                const row = dropTarget.closest('tr');
                                if (row) {
                                    const dateCell = row.querySelector('td:nth-child(2)');
                                    if (dateCell) {
                                        const dateCellText = dateCell.textContent;
                                        const dayMatch = dateCellText.match(/^(\d+)\(/);
                                        if (dayMatch) {
                                            changedDay = parseInt(dayMatch[1]);
                                        }
                                    }
                                }
                            }

                            // 自動保存を実行（移動元と移動先の両方）
                            console.log('🔍 自動保存チェック:', {
                                changedDay,
                                originDay,
                                autoSaveFunctionExists: typeof autoSaveMagnetPlacement === 'function'
                            });

                            if (typeof autoSaveMagnetPlacement === 'function') {
                                // 移動先を保存
                                if (changedDay !== null) {
                                    console.log(`💾 自動保存: 移動先 ${changedDay}日を保存`);
                                    autoSaveMagnetPlacement(changedDay);
                                }
                                // 移動元も保存（移動先と異なる場合）
                                if (originDay !== null && originDay !== changedDay) {
                                    console.log(`💾 自動保存: 移動元 ${originDay}日を保存`);
                                    autoSaveMagnetPlacement(originDay);
                                }
                            } else {
                                console.error('❌ autoSaveMagnetPlacement関数が見つかりません');
                            }
                        }

                        // drag-over 状態をクリア
                        if (currentDragOverZone) {
                            currentDragOverZone.classList.remove('drag-over');
                            currentDragOverZone = null;
                        }

                        // ドラッグ完了後にクリーンアップ
                        isDragging = false;
                        if (draggedMagnet) {
                            draggedMagnet.classList.remove('dragging'); // ドラッグ中のスタイルを削除
                            draggedMagnet = null;
                        }

                        // 自動スクロールを停止
                        if (autoScrollInterval) {
                            clearInterval(autoScrollInterval);
                            autoScrollInterval = null;
                        }
                    });

                    // dragend: ドラッグ終了時のクリーンアップ
                    document.addEventListener('dragend', e => {
                        isDragging = false; // ドラッグ終了
                        if (draggedMagnet) {
                            draggedMagnet.classList.remove('dragging'); // ドラッグ中のスタイルを削除
                            draggedMagnet = null; // ドラッグ中のマグネットをクリア
                        }
                        if (currentDragOverZone) {
                            currentDragOverZone.classList.remove('drag-over');
                            currentDragOverZone = null;
                        }

                        // 自動スクロールを停止
                        if (autoScrollInterval) {
                            clearInterval(autoScrollInterval);
                            autoScrollInterval = null;
                        }
                    });

                    // ドラッグが中断された場合のクリーンアップ（マウスがウィンドウ外に出た場合など）
                    document.addEventListener('mouseup', e => {
                        if (isDragging) {
                            isDragging = false;
                            if (draggedMagnet) {
                                draggedMagnet.classList.remove('dragging'); // ドラッグ中のスタイルを削除
                                draggedMagnet = null;
                            }
                            if (currentDragOverZone) {
                                currentDragOverZone.classList.remove('drag-over');
                                currentDragOverZone = null;
                            }

                            // 自動スクロールを停止
                            if (autoScrollInterval) {
                                clearInterval(autoScrollInterval);
                                autoScrollInterval = null;
                            }
                        }
                    });

                    dragEventsInitialized = true;
                }

                // dblclick はテーブルに対してのみ設定（軽量）
                if (!table.hasAttribute('data-dblclick-setup')) {
                    table.addEventListener('dblclick', e => {
                        if (e.target.classList.contains('magnet') || e.target.closest('.magnet')) {
                            openRecordModal(e.target.closest('.magnet'));
                        }
                    });
                    table.setAttribute('data-dblclick-setup', 'true');
                }
            }

            // 時刻文字列（HH:MM）を分に変換
            function timeToMinutes(timeStr) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }

            // 分を時刻文字列（HH:MM）に変換
            function minutesToTime(minutes) {
                const h = Math.floor(minutes / 60);
                const m = minutes % 60;
                return `${h}:${String(m).padStart(2, '0')}`;
            }

            // セルの時間サマリーを計算して更新
            function updateCellTimeSummary(cell) {
                const timeSummary = cell.querySelector('.time-summary');
                if (!timeSummary) return;

                const magnets = Array.from(cell.querySelectorAll('.magnet'));

                if (magnets.length === 0) {
                    timeSummary.querySelector('.start-time').textContent = '-';
                    timeSummary.querySelector('.end-time').textContent = '-';
                    timeSummary.querySelector('.break-time').textContent = '0:00';
                    timeSummary.querySelector('.work-time').textContent = '0:00';
                    return;
                }

                // マグネットの時間を解析
                const timeRanges = [];
                magnets.forEach(magnet => {
                    const timeStr = magnet.dataset.time;
                    const match = timeStr.match(/(\d{2}:\d{2})-(\d{2}:\d{2})/);
                    if (match) {
                        timeRanges.push({
                            start: match[1],
                            end: match[2],
                            startMinutes: timeToMinutes(match[1]),
                            endMinutes: timeToMinutes(match[2])
                        });
                    }
                });

                if (timeRanges.length === 0) {
                    timeSummary.querySelector('.start-time').textContent = '-';
                    timeSummary.querySelector('.end-time').textContent = '-';
                    timeSummary.querySelector('.break-time').textContent = '0:00';
                    timeSummary.querySelector('.work-time').textContent = '0:00';
                    return;
                }

                // 開始時刻と終了時刻を取得
                timeRanges.sort((a, b) => a.startMinutes - b.startMinutes);
                const firstStart = timeRanges[0].start;
                const lastEnd = timeRanges.reduce((max, range) =>
                    range.endMinutes > timeToMinutes(max) ? range.end : max, timeRanges[0].end);

                // 休憩時間を計算（マグネット間の空き時間が90分以上あれば1:00）
                let breakTime = 0;
                for (let i = 0; i < timeRanges.length - 1; i++) {
                    const currentEnd = timeRanges[i].endMinutes;
                    const nextStart = timeRanges[i + 1].startMinutes;
                    const gap = nextStart - currentEnd;
                    if (gap >= 90) {
                        breakTime = 60; // 1時間
                        break;
                    }
                }

                // 実働時間を計算（終業時刻 - 始業時刻 - 休憩時間）
                const totalMinutes = timeToMinutes(lastEnd) - timeToMinutes(firstStart);
                const workMinutes = totalMinutes - breakTime;

                // 表示を更新
                timeSummary.querySelector('.start-time').textContent = firstStart;
                timeSummary.querySelector('.end-time').textContent = lastEnd;
                timeSummary.querySelector('.break-time').textContent = minutesToTime(breakTime);
                timeSummary.querySelector('.work-time').textContent = minutesToTime(workMinutes);
            }

            // 全セルの時間サマリーを更新（最適化: 描画済みの行のみ処理）
            function updateAllTimeSummaries() {
                // 描画済みの行のみ処理してフリーズを防止
                const renderedRows = document.querySelectorAll('#shift-table tbody tr[data-rendered="true"]');
                renderedRows.forEach(row => {
                    const cells = row.querySelectorAll('td.drop-zone:not(.storage-location)');
                    cells.forEach(cell => updateCellTimeSummary(cell));
                });
            }

            // 部分更新版: 特定の担当者の合計時間のみ更新（最適化: 描画済みの行のみ処理）
            function updateStaffTotal(staffName, staffIndex) {
                const totalSpan = document.getElementById(`total-${staffName}`);
                const constraintSpan = document.getElementById(`constraint-${staffName}`);
                const thirtyMinSpan = document.getElementById(`thirty-min-${staffName}`);
                const companyBurdenSpan = document.getElementById(`company-burden-${staffName}`);

                let totalMinutes = 0; // サービス時間
                let totalConstraintMinutes = 0; // 拘束時間
                let totalServiceMinutesFor30min = 0; // 30分回数計算用の合計時間
                let totalCompanyBurdenCount = 0; // 会社負担の回数

                // 全ての行を処理（週合計行は除く）
                const allRows = table.querySelectorAll(`#shift-table tbody tr:not(.week-summary-row)`);
                allRows.forEach(row => {
                    const cell = row.querySelector(`td:nth-child(${staffIndex + 3})`);
                    if (cell && cell.classList.contains('drop-zone')) {
                        // サービス時間を計算
                        const magnets = Array.from(cell.querySelectorAll('.magnet'));

                        // マグネットを時刻順にソート
                        magnets.sort((a, b) => {
                            const timeA = a.dataset.time || '';
                            const timeB = b.dataset.time || '';
                            const startA = timeA.split('-')[0] || timeA.split('~')[0] || '';
                            const startB = timeB.split('-')[0] || timeB.split('~')[0] || '';
                            return startA.localeCompare(startB);
                        });

                        // 連続したサービスを見つけて除外する
                        const excludedMagnets = new Set();

                        magnets.forEach((magnet, index) => {
                            const userName = magnet.dataset.user || '';
                            const timeStr = magnet.dataset.time || '';
                            const duration = parseInt(magnet.dataset.durationMinutes, 10) || 0;

                            totalMinutes += duration;

                            // 会社負担のマグネットをカウント
                            if (magnet.classList.contains('company-burden')) {
                                totalCompanyBurdenCount++;
                            }

                            // 時刻を分割
                            const timeParts = timeStr.split('-').length > 1 ? timeStr.split('-') : timeStr.split('~');
                            if (timeParts.length === 2 && index < magnets.length - 1) {
                                const endTime = timeParts[1].trim();

                                // 次のマグネットをチェック
                                const nextMagnet = magnets[index + 1];
                                const nextUserName = nextMagnet.dataset.user || '';
                                const nextTimeStr = nextMagnet.dataset.time || '';
                                const nextTimeParts = nextTimeStr.split('-').length > 1 ? nextTimeStr.split('-') : nextTimeStr.split('~');

                                if (nextTimeParts.length === 2) {
                                    const nextStartTime = nextTimeParts[0].trim();

                                    // 同じ利用者で連続している場合、両方を除外
                                    if (userName === nextUserName && endTime === nextStartTime) {
                                        excludedMagnets.add(magnet);
                                        excludedMagnets.add(nextMagnet);
                                    }
                                }
                            }
                        });

                        // 除外されていないマグネットの合計時間を計算
                        magnets.forEach(magnet => {
                            if (!excludedMagnets.has(magnet)) {
                                const duration = parseInt(magnet.dataset.durationMinutes, 10) || 0;
                                totalServiceMinutesFor30min += duration;
                            }
                        });

                        // 拘束時間を計算（開始～終了時間）
                        const timeSummary = cell.querySelector('.time-summary');
                        if (timeSummary) {
                            const startTimeText = timeSummary.querySelector('.start-time').textContent;
                            const endTimeText = timeSummary.querySelector('.end-time').textContent;

                            if (startTimeText !== '-' && endTimeText !== '-') {
                                const startMinutes = timeToMinutes(startTimeText);
                                const endMinutes = timeToMinutes(endTimeText);

                                if (endMinutes >= startMinutes) {
                                    totalConstraintMinutes += (endMinutes - startMinutes);
                                }
                            }
                        }
                    }
                });

                // 30分回数を計算（合計時間を30分で割って切り捨て）
                const thirtyMinCount = Math.floor(totalServiceMinutesFor30min / 30);

                // 表示を更新（inputタグのvalueを更新）
                if (totalSpan) {
                    totalSpan.value = (totalMinutes / 60).toFixed(1);
                }
                if (constraintSpan) {
                    constraintSpan.value = (totalConstraintMinutes / 60).toFixed(1);
                }
                if (thirtyMinSpan) {
                    thirtyMinSpan.value = thirtyMinCount;
                }
                if (companyBurdenSpan) {
                    companyBurdenSpan.value = totalCompanyBurdenCount;
                }
            }

            // 全担当者の合計時間を更新（既存コードとの互換性のため残す）
            // 週合計を更新する関数
            function updateWeeklySummaries() {
                const weekSummaryRows = table.querySelectorAll('tr.week-summary-row');

                weekSummaryRows.forEach(weekRow => {
                    const weekStart = parseInt(weekRow.dataset.weekStart);
                    const weekEnd = parseInt(weekRow.dataset.weekEnd);

                    staffNames.forEach((staffName, staffIndex) => {
                        let weekTotalMinutes = 0; // 拘束時間（分）
                        let weekServiceMinutes = 0; // サービス時間（分）

                        // 週の範囲内の全ての日付行を走査
                        const allRows = table.querySelectorAll('tbody tr:not(.week-summary-row)');
                        allRows.forEach(row => {
                            const dayNumber = parseInt(row.dataset.dayNumber);
                            if (dayNumber >= weekStart && dayNumber <= weekEnd) {
                                // 該当する担当者のセルを取得（3列目から始まる）
                                const cell = row.querySelector(`td:nth-child(${staffIndex + 3})`);
                                if (cell && cell.classList.contains('drop-zone')) {
                                    const timeSummary = cell.querySelector('.time-summary');
                                    if (timeSummary) {
                                        // 拘束時間を計算（開始～終了）
                                        const startTimeText = timeSummary.querySelector('.start-time').textContent;
                                        const endTimeText = timeSummary.querySelector('.end-time').textContent;
                                        const breakTimeText = timeSummary.querySelector('.break-time').textContent;

                                        if (startTimeText !== '-' && endTimeText !== '-') {
                                            const startMinutes = timeToMinutes(startTimeText);
                                            const endMinutes = timeToMinutes(endTimeText);
                                            const breakMinutes = timeToMinutes(breakTimeText);

                                            if (endMinutes >= startMinutes) {
                                                weekTotalMinutes += (endMinutes - startMinutes);
                                            }
                                        }

                                        // サービス時間を計算（マグネットの合計時間）
                                        const workTimeText = timeSummary.querySelector('.work-time').textContent;
                                        weekServiceMinutes += timeToMinutes(workTimeText);
                                    }
                                }
                            }
                        });

                        // 週合計を表示
                        const weekTotalHoursSpan = weekRow.querySelector(`.week-total-hours[data-staff="${staffName}"]`);
                        const weekServiceHoursSpan = weekRow.querySelector(`.week-service-hours[data-staff="${staffName}"]`);

                        if (weekTotalHoursSpan) {
                            weekTotalHoursSpan.textContent = (weekTotalMinutes / 60).toFixed(1);
                        }
                        if (weekServiceHoursSpan) {
                            weekServiceHoursSpan.textContent = (weekServiceMinutes / 60).toFixed(1);
                        }
                    });
                });
            }

            function updateAllHours() {
                updateAllTimeSummaries();

                // 既存の合計時間も更新（下部のフッター用）
                staffNames.forEach((name, index) => {
                    updateStaffTotal(name, index);
                });

                // 週合計を更新
                updateWeeklySummaries();
            }

            // コンテキストメニュー機能
            function showContextMenu(x, y, magnet) {
                contextTargetMagnet = magnet;

                // 同行マグネットの場合のみ複製ボタンを表示
                const serviceType = magnet.dataset.service || '';
                if (serviceType.includes('同行')) {
                    contextDuplicate.style.display = 'block';
                } else {
                    contextDuplicate.style.display = 'none';
                }

                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
                contextMenu.classList.add('visible');
            }

            function hideContextMenu() {
                contextMenu.classList.remove('visible');
                contextTargetMagnet = null;
            }

            // セル用コンテキストメニュー機能
            function showCellContextMenu(x, y, cell) {
                contextTargetCell = cell;
                cellContextMenu.style.left = `${x}px`;
                cellContextMenu.style.top = `${y}px`;
                cellContextMenu.classList.add('visible');
            }

            function hideCellContextMenu() {
                cellContextMenu.classList.remove('visible');
                contextTargetCell = null;
            }

            // 右クリックでコンテキストメニューを表示
            document.addEventListener('contextmenu', e => {
                const magnet = e.target.closest('.magnet');
                const cell = e.target.closest('td.drop-zone:not(.storage-location)');

                if (magnet) {
                    // マグネット上での右クリック
                    e.preventDefault();
                    hideCellContextMenu();
                    showContextMenu(e.pageX, e.pageY, magnet);
                } else if (cell && cell.cellIndex >= 2) {
                    // セル上での右クリック（保管場所と日付列を除く）
                    e.preventDefault();
                    hideContextMenu();
                    showCellContextMenu(e.pageX, e.pageY, cell);
                } else {
                    // それ以外
                    hideContextMenu();
                    hideCellContextMenu();
                }
            });

            // 画面クリックでコンテキストメニューを閉じる
            document.addEventListener('click', e => {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
                if (!cellContextMenu.contains(e.target)) {
                    hideCellContextMenu();
                }
            });

            // 公休・有給の数を自動カウントして更新する関数
            function updateLeaveCount() {
                staffNames.forEach((staffName, index) => {
                    let koukuyuCount = 0;
                    let yuukyuCount = 0;
                    let tokkyuCount = 0;

                    // その担当者の全セルを確認
                    const cells = document.querySelectorAll(`#shift-table tbody td:nth-child(${index + 3})`);
                    cells.forEach(cell => {
                        if (cell.classList.contains('cell-koukyu')) {
                            koukuyuCount++;
                        } else if (cell.classList.contains('cell-yuukyu')) {
                            yuukyuCount++;
                        } else if (cell.classList.contains('cell-tokkyu')) {
                            tokkyuCount++;
                        }
                    });

                    // 公休・有給・特休の入力欄を更新
                    const koukyuInput = document.querySelector(`.leave-input[data-staff="${staffName}"]`);
                    const yuukyuInput = document.querySelectorAll(`.leave-input[data-staff="${staffName}"]`)[1];
                    const tokkyuInput = document.querySelector(`.leave-input-tokkyu[data-staff="${staffName}"]`);

                    if (koukyuInput) {
                        koukyuInput.value = koukuyuCount;
                    }
                    if (yuukyuInput) {
                        yuukyuInput.value = yuukyuCount;
                    }
                    if (tokkyuInput) {
                        tokkyuInput.value = tokkyuCount;
                    }
                });
            }

            // セルコンテキストメニュー：追加
            cellContextAdd.addEventListener('click', () => {
                if (contextTargetCell) {
                    // クリックしたセルから担当者と日付を取得
                    const row = contextTargetCell.closest('tr');
                    if (!row) {
                        hideCellContextMenu();
                        return;
                    }

                    // 日付を取得（2列目のセル）
                    const dateCell = row.querySelector('td:nth-child(2)');
                    if (!dateCell) {
                        hideCellContextMenu();
                        return;
                    }

                    const dateCellText = dateCell.textContent;
                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                    if (!dayMatch) {
                        hideCellContextMenu();
                        return;
                    }

                    const day = parseInt(dayMatch[1]);
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                    // 担当者を取得（セルのインデックスから）
                    const cells = Array.from(row.querySelectorAll('td.drop-zone:not(.storage-location)'));
                    const cellIndex = cells.indexOf(contextTargetCell);
                    const staffName = staffNames[cellIndex];

                    if (!staffName) {
                        hideCellContextMenu();
                        return;
                    }

                    // モーダルを開く
                    loadUsersFromFirebase();
                    createModal.classList.add('visible');

                    // 担当者と日付を自動入力
                    createModalStaffSearch.value = staffName;
                    createModalDateInput.value = day;

                    // flatpickrのインスタンスがあれば日付を設定
                    if (createModalDateInput._flatpickr) {
                        createModalDateInput._flatpickr.setDate(dateStr);
                    }
                }
                hideCellContextMenu();
            });

            // セルコンテキストメニュー：公休
            cellContextKoukyu.addEventListener('click', () => {
                if (contextTargetCell) {
                    saveStateToUndo();
                    contextTargetCell.classList.remove('cell-yuukyu');
                    contextTargetCell.classList.remove('cell-tokkyu');
                    contextTargetCell.classList.add('cell-koukyu');
                    // インラインスタイルで強制的に背景色を設定
                    contextTargetCell.style.backgroundColor = '#c8e6c9';
                    updateLeaveCount();
                    autoSaveCellStates(); // セル状態を保存
                }
                hideCellContextMenu();
            });

            // セルコンテキストメニュー：有給
            cellContextYuukyu.addEventListener('click', () => {
                if (contextTargetCell) {
                    saveStateToUndo();
                    contextTargetCell.classList.remove('cell-koukyu');
                    contextTargetCell.classList.remove('cell-tokkyu');
                    contextTargetCell.classList.add('cell-yuukyu');
                    // インラインスタイルで強制的に背景色を設定
                    contextTargetCell.style.backgroundColor = '#ffe0b2';
                    updateLeaveCount();
                    autoSaveCellStates(); // セル状態を保存
                }
                hideCellContextMenu();
            });

            // セルコンテキストメニュー：特休
            cellContextTokkyu.addEventListener('click', () => {
                console.log('💙 特休ボタンがクリックされました');
                if (contextTargetCell) {
                    console.log('💙 対象セル:', contextTargetCell);
                    saveStateToUndo();
                    contextTargetCell.classList.remove('cell-koukyu');
                    contextTargetCell.classList.remove('cell-yuukyu');
                    contextTargetCell.classList.add('cell-tokkyu');
                    // インラインスタイルで強制的に背景色を設定
                    contextTargetCell.style.backgroundColor = '#e3f2fd';
                    console.log('💙 クラス追加後:', contextTargetCell.className);
                    console.log('💙 背景色設定後:', contextTargetCell.style.backgroundColor);
                    updateLeaveCount();
                    autoSaveCellStates(); // セル状態を保存
                }
                hideCellContextMenu();
            });

            // セルコンテキストメニュー：クリア
            cellContextClear.addEventListener('click', () => {
                if (contextTargetCell) {
                    saveStateToUndo();
                    contextTargetCell.classList.remove('cell-koukyu', 'cell-yuukyu', 'cell-tokkyu');
                    // インラインスタイルの背景色を削除
                    contextTargetCell.style.backgroundColor = '';
                    updateLeaveCount();
                    autoSaveCellStates(); // セル状態を保存
                }
                hideCellContextMenu();
            });

            // 移動ボタンクリック時
            contextMove.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    cancelCut(); // 既存のカット状態をクリア
                    cutMagnet = contextTargetMagnet;
                    cutMagnet.classList.add('cut');

                    const originCell = cutMagnet.parentElement;
                    const dateCell = originCell.closest('tr')?.querySelector('td:nth-child(2)');
                    moveOriginInfo = {
                        from: getLocationName(originCell),
                        date: dateCell ? dateCell.textContent : '未割り当てBOX'
                    };
                }
                hideContextMenu();
            });

            // 複製ボタンクリック時（同行マグネットのみ）
            contextDuplicate.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    saveStateToUndo();
                    const userName = contextTargetMagnet.dataset.user;
                    const serviceType = contextTargetMagnet.dataset.service;
                    const time = contextTargetMagnet.dataset.time;
                    const durationMinutes = contextTargetMagnet.dataset.durationMinutes;

                    // 複製マグネットを作成（★マークを付ける）
                    const magnetData = {
                        id: 'duplicated-' + Date.now() + '-' + Math.random(),
                        userName: '★' + userName,
                        serviceType: serviceType,
                        time: time,
                        duration: durationMinutes,
                        isAccompanyStar: true,
                        companionOriginalStaff: getLocationName(contextTargetMagnet.parentElement)
                    };

                    const duplicatedMagnet = createMagnet(magnetData);

                    // 元のマグネットと同じセルに追加
                    const parentCell = contextTargetMagnet.parentElement;
                    parentCell.appendChild(duplicatedMagnet);
                    sortMagnetsInCell(parentCell);
                    updateAllHours();
                    setupDragAndDrop();

                    // 履歴に追加
                    const locationName = getLocationName(parentCell);
                    const dateCell = parentCell.closest('tr')?.querySelector('td:nth-child(2)');
                    const dateText = dateCell ? dateCell.textContent : '不明';
                    addHistoryEntry(
                        `${userName} ${serviceType} ${time}`,
                        '複製',
                        locationName,
                        dateText
                    );
                }
                hideContextMenu();
            });

            // 同行ボタンクリック時（すべてのマグネット）
            contextAccompany.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    saveStateToUndo();
                    const userName = contextTargetMagnet.dataset.user;
                    const serviceType = contextTargetMagnet.dataset.service;
                    const time = contextTargetMagnet.dataset.time;
                    const durationMinutes = contextTargetMagnet.dataset.durationMinutes;

                    // 複製元のマグネットを黄色にする
                    applyColorClass(contextTargetMagnet, 'color-yellow');
                    contextTargetMagnet.dataset.accompanyPair = 'origin'; // ペア識別用
                    contextTargetMagnet.dataset.colorClass = 'color-yellow';
                    contextTargetMagnet.dataset.isAccompany = 'true';

                    // 同行マグネットを作成（★マークを付ける）
                    const magnetData = {
                        id: 'accompany-' + Date.now() + '-' + Math.random(),
                        userName: userName, // ★マークは表示側で追加
                        serviceType: serviceType,
                        time: time,
                        duration: durationMinutes,
                        isAccompanyStar: true,
                        isAccompany: true,
                        accompanyPair: 'copy', // ペア識別用
                        colorClass: 'color-yellow',
                        companionOriginalStaff: getLocationName(contextTargetMagnet.parentElement)
                    };

                    const accompanyMagnet = createMagnet(magnetData);

                    // 元のマグネットと同じセルに追加
                    const parentCell = contextTargetMagnet.parentElement;
                    parentCell.appendChild(accompanyMagnet);
                    sortMagnetsInCell(parentCell);
                    updateAllHours();
                    setupDragAndDrop();

                    // 自動保存
                    scheduleSave();

                    // 履歴に追加
                    const locationName = getLocationName(parentCell);
                    const dateCell = parentCell.closest('tr')?.querySelector('td:nth-child(2)');
                    const dateText = dateCell ? dateCell.textContent : '不明';
                    addHistoryEntry(
                        `${userName} ${serviceType} ${time}`,
                        '同行',
                        locationName,
                        dateText
                    );
                }
                hideContextMenu();
            });

            // キャンセルボタンクリック時
            contextCancel.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    saveStateToUndo();
                    const userName = contextTargetMagnet.dataset.user;
                    const serviceType = contextTargetMagnet.dataset.service;
                    const time = contextTargetMagnet.dataset.time;

                    // キャンセル状態を記録
                    contextTargetMagnet.dataset.cancelled = 'true';

                    // 赤色に変更
                    contextTargetMagnet.classList.remove('color-yellow', 'color-orange', 'color-blue');
                    contextTargetMagnet.classList.add('color-red');

                    // 仮想スクロール用：allDaysDataを同期
                    const parentCell = contextTargetMagnet.parentElement;
                    syncCellToAllDaysData(parentCell);

                    // 履歴に追加
                    const locationName = getLocationName(parentCell);
                    const dateCell = parentCell.closest('tr')?.querySelector('td:nth-child(2)');
                    const dateText = dateCell ? dateCell.textContent : '不明';
                    addHistoryEntry(
                        `${userName} ${serviceType} ${time}`,
                        locationName,
                        'キャンセル',
                        dateText
                    );

                    // 変更連絡を記録（キャンセル）
                    let cancelDate = '';
                    if (dateCell) {
                        const dayMatch = dateCell.textContent.match(/^(\d+)\(/);
                        if (dayMatch) {
                            const day = parseInt(dayMatch[1]);
                            const year = currentDate.getFullYear();
                            const month = currentDate.getMonth() + 1;
                            cancelDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        }
                    }

                    saveChangeNotification({
                        userName: userName,
                        date: cancelDate || new Date().toISOString().split('T')[0],
                        changeType: 'キャンセル',
                        staffName: locationName,
                        serviceName: serviceType,
                        details: `${userName} ${serviceType} ${time} をキャンセル`,
                        time: time
                    });
                }
                hideContextMenu();
            });

            // 削除ボタンクリック時
            contextDelete.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    const userName = contextTargetMagnet.dataset.user;
                    const serviceType = contextTargetMagnet.dataset.service;
                    const time = contextTargetMagnet.dataset.time;

                    if (confirm(`「${userName} ${serviceType} ${time}」を削除しますか？`)) {
                        console.log('🔵 マグネット削除開始');
                        saveStateToUndo();
                        const parentCell = contextTargetMagnet.parentElement;

                        // 削除前に日付を取得（自動保存用）
                        let changedDay = null;
                        if (parentCell.id === 'unassigned-box') {
                            changedDay = 'unassigned';
                        } else {
                            const row = parentCell.closest('tr');
                            if (row) {
                                const dateCell = row.querySelector('td:nth-child(2)');
                                if (dateCell) {
                                    const dateCellText = dateCell.textContent;
                                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                                    if (dayMatch) {
                                        changedDay = parseInt(dayMatch[1]);
                                    }
                                }
                            }
                        }
                        console.log('🔵 削除時のchangedDay:', changedDay);

                        contextTargetMagnet.remove();
                        updateAllHours();

                        // 履歴に追加
                        const locationName = getLocationName(parentCell);
                        const dateCell = parentCell.closest('tr')?.querySelector('td:nth-child(2)');
                        const dateText = dateCell ? dateCell.textContent : '不明';
                        addHistoryEntry(
                            `${userName} ${serviceType} ${time}`,
                            locationName,
                            '削除',
                            dateText
                        );

                        // 自動保存を実行
                        console.log('🔵 削除時のautoSaveMagnetPlacement存在確認:', typeof autoSaveMagnetPlacement);
                        if (changedDay !== null && typeof autoSaveMagnetPlacement === 'function') {
                            console.log(`💾 削除後の自動保存トリガー: ${changedDay}日`);
                            autoSaveMagnetPlacement(changedDay);
                        } else {
                            console.log('❌ 削除時の自動保存がスキップされました - changedDay:', changedDay, 'typeof:', typeof autoSaveMagnetPlacement);
                        }
                    }
                }
                hideContextMenu();
            });

            // 会社負担ボタンクリック時
            contextCompanyBurden.addEventListener('click', () => {
                if (contextTargetMagnet) {
                    saveStateToUndo();

                    // 会社負担クラスのトグル + インラインスタイル設定
                    if (contextTargetMagnet.classList.contains('company-burden')) {
                        contextTargetMagnet.classList.remove('company-burden');
                        // インラインスタイルを削除
                        contextTargetMagnet.style.backgroundColor = '';
                        contextTargetMagnet.style.color = '';
                        // 子要素の色も戻す
                        const userSpan = contextTargetMagnet.querySelector('.magnet-user');
                        const contentSpan = contextTargetMagnet.querySelector('.magnet-content');
                        if (userSpan) userSpan.style.color = '';
                        if (contentSpan) contentSpan.style.color = '';
                    } else {
                        contextTargetMagnet.classList.add('company-burden');
                        // インラインスタイルで強制的に設定
                        contextTargetMagnet.style.backgroundColor = '#9370db';
                        contextTargetMagnet.style.color = 'white';
                        // 子要素の色も設定
                        const userSpan = contextTargetMagnet.querySelector('.magnet-user');
                        const contentSpan = contextTargetMagnet.querySelector('.magnet-content');
                        if (userSpan) userSpan.style.color = 'white';
                        if (contentSpan) contentSpan.style.color = 'white';
                    }

                    // 自動保存を実行
                    const parentCell = contextTargetMagnet.parentElement;
                    let changedDay = null;
                    if (parentCell.id !== 'unassigned-box') {
                        const row = parentCell.closest('tr');
                        if (row) {
                            const dateCell = row.querySelector('td:nth-child(2)');
                            if (dateCell) {
                                const dateCellText = dateCell.textContent;
                                const dayMatch = dateCellText.match(/^(\d+)\(/);
                                if (dayMatch) {
                                    changedDay = parseInt(dayMatch[1]);
                                }
                            }
                        }
                    }

                    if (changedDay !== null && typeof autoSaveMagnetPlacement === 'function') {
                        autoSaveMagnetPlacement(changedDay);
                    }
                }
                hideContextMenu();
            });

            // クリック移動機能を削除し、右クリックメニューの「移動」機能を使用
            table.addEventListener('click', e => {
                const clickedCell = e.target.closest('.drop-zone');

                if (e.target.classList.contains('leave-input')) {
                    e.stopPropagation();
                    return;
                }

                // cutMagnetがある場合は移動先クリックとして処理
                if (clickedCell && cutMagnet) {
                    const magnetUser = cutMagnet.dataset.user;
                    const magnetTime = cutMagnet.dataset.time;
                    const to = getLocationName(clickedCell);
                    const from = moveOriginInfo ? moveOriginInfo.from : '不明';

                    // 確認ダイアログを表示
                    const message = `「${magnetUser} ${magnetTime}」のシフトを\n「${from}」から「${to}」に移動させます。\n\nよろしいですか？`;
                    if (confirm(message)) {
                        saveStateToUndo();

                        if (moveOriginInfo && moveOriginInfo.from !== to) {
                            addHistoryEntry(cutMagnet.innerHTML, moveOriginInfo.from, to, moveOriginInfo.date);
                        }

                        const originCell = cutMagnet.parentElement;
                        clickedCell.appendChild(cutMagnet);
                        sortMagnetsInCell(clickedCell);

                        // 部分更新: 移動元と移動先のセルのみ更新
                        updateCellTimeSummary(clickedCell);
                        if (originCell && originCell.id !== 'unassigned-box') {
                            updateCellTimeSummary(originCell);
                        }

                        // 担当者の合計時間を部分更新
                        if (clickedCell.id !== 'unassigned-box') {
                            const row = clickedCell.closest('tr');
                            if (row) {
                                const cells = Array.from(row.querySelectorAll('td.drop-zone:not(.storage-location)'));
                                const index = cells.indexOf(clickedCell);
                                if (index !== -1 && staffNames[index]) {
                                    updateStaffTotal(staffNames[index], index);
                                }
                            }
                        }
                        if (originCell && originCell.id !== 'unassigned-box') {
                            const row = originCell.closest('tr');
                            if (row) {
                                const cells = Array.from(row.querySelectorAll('td.drop-zone:not(.storage-location)'));
                                const index = cells.indexOf(originCell);
                                if (index !== -1 && staffNames[index]) {
                                    updateStaffTotal(staffNames[index], index);
                                }
                            }
                        }

                        // 自動保存
                        if (clickedCell.id === 'unassigned-box') {
                            autoSaveMagnetPlacement('unassigned');
                        } else {
                            const row = clickedCell.closest('tr');
                            if (row) {
                                const dateCell = row.querySelector('td:nth-child(2)');
                                if (dateCell) {
                                    const dayMatch = dateCell.textContent.match(/^(\d+)\(/);
                                    if (dayMatch) {
                                        autoSaveMagnetPlacement(parseInt(dayMatch[1]));
                                    }
                                }
                            }
                        }
                    }

                    cancelCut();
                }
            });

            document.addEventListener('keydown', e => {
                if (e.key === "Escape") {
                    cancelCut();
                }
            });

            // 中抜けチェックボックスの変更イベント
            createModalBreakCheckbox.addEventListener('change', () => {
                const isBreak = createModalBreakCheckbox.checked;
                const userInput = document.getElementById('modal-user-search');
                const serviceInput = document.getElementById('modal-service-input');
                const serviceDisplayInput = document.getElementById('modal-service-display');

                if (isBreak) {
                    userInput.disabled = true;
                    userInput.value = '';
                    if (serviceDisplayInput) serviceDisplayInput.required = false;
                    if (serviceDisplayInput) serviceDisplayInput.disabled = true;
                    if (serviceDisplayInput) serviceDisplayInput.value = '';
                    serviceInput.value = '';
                    if (modalNightFlag) {
                        modalNightFlag.checked = false;
                        modalNightFlag.disabled = true;
                    }
                } else {
                    userInput.disabled = false;
                    if (serviceDisplayInput) serviceDisplayInput.required = true;
                    if (serviceDisplayInput) serviceDisplayInput.disabled = false;
                    if (modalNightFlag) {
                        modalNightFlag.disabled = false;
                    }
                }
            });

            // モーダルを開く時に利用者データを読み込む
            createMagnetBtn.addEventListener('click', () => {
                loadUsersFromFirebase();
                createModal.classList.add('visible');
            });

            createModalCancelBtn.addEventListener('click', () => {
                createModal.classList.remove('visible');
                createModalForm.reset();
                createModalBreakCheckbox.checked = false;
                document.getElementById('modal-user-search').disabled = false;
                if (modalNightFlag) modalNightFlag.checked = false;
                const serviceDisplay = document.getElementById('modal-service-display');
                if (serviceDisplay) {
                    serviceDisplay.disabled = false;
                    serviceDisplay.required = true;
                    serviceDisplay.value = '';
                }
                document.getElementById('modal-service-input').value = '';
                if (modalNightFlag) modalNightFlag.checked = false;
            });
            createModal.addEventListener('click', e => {
                if (e.target === createModal) {
                    createModal.classList.remove('visible');
                    createModalForm.reset();
                    createModalBreakCheckbox.checked = false;
                    document.getElementById('modal-user-search').disabled = false;
                    if (modalNightFlag) modalNightFlag.checked = false;
                    const serviceDisplay = document.getElementById('modal-service-display');
                    if (serviceDisplay) {
                        serviceDisplay.disabled = false;
                        serviceDisplay.required = true;
                        serviceDisplay.value = '';
                    }
                    document.getElementById('modal-service-input').value = '';
                }
            });



            // --- REPLACEMENT (FIXED): Dynamic Service Candidate Filtering Logic ---
            const serviceDisplayInput = document.getElementById('modal-service-display');
            const serviceDropdown = document.getElementById('service-selector-dropdown');
            const serviceInput = document.getElementById('modal-service-input');
            const modalStartTimeInput = document.getElementById('modal-start-time');
            const modalEndTimeInput = document.getElementById('modal-end-time');
            const modalNightFlag = document.getElementById('modal-night-flag');

            /**
             * @typedef {'body' | 'life' | 'combo'} ServiceKind
             * @typedef {{ code: string; label: string; kind: ServiceKind; minBodyMinutes: number; minLifeMinutes: number; minTotalMinutes: number; maxTotalMinutes: number; }} ServiceDefinition
             * @typedef {'care'} ServiceFilterMode
             */
            /** @type {ServiceDefinition[]} */
            const SERVICE_DEFINITIONS_DAY = [
                // ===== 身体のみ =====
                { code: "111111", label: "身体介護1", kind: "body", minBodyMinutes: 20, minLifeMinutes: 0, minTotalMinutes: 20, maxTotalMinutes: 30 },
                { code: "111211", label: "身体介護2", kind: "body", minBodyMinutes: 30, minLifeMinutes: 0, minTotalMinutes: 30, maxTotalMinutes: 60 },
                { code: "111311", label: "身体介護3", kind: "body", minBodyMinutes: 60, minLifeMinutes: 0, minTotalMinutes: 60, maxTotalMinutes: 90 },
                { code: "111411", label: "身体介護4", kind: "body", minBodyMinutes: 90, minLifeMinutes: 0, minTotalMinutes: 90, maxTotalMinutes: 120 },
                { code: "111511", label: "身体介護5", kind: "body", minBodyMinutes: 120, minLifeMinutes: 0, minTotalMinutes: 120, maxTotalMinutes: 150 },
                { code: "111611", label: "身体介護6", kind: "body", minBodyMinutes: 150, minLifeMinutes: 0, minTotalMinutes: 150, maxTotalMinutes: 180 },
                { code: "111711", label: "身体介護7", kind: "body", minBodyMinutes: 180, minLifeMinutes: 0, minTotalMinutes: 180, maxTotalMinutes: 210 },
                { code: "111811", label: "身体介護8", kind: "body", minBodyMinutes: 210, minLifeMinutes: 0, minTotalMinutes: 210, maxTotalMinutes: 240 },
                { code: "111911", label: "身体介護9", kind: "body", minBodyMinutes: 240, minLifeMinutes: 0, minTotalMinutes: 240, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 生活のみ =====
                { code: "117211", label: "生活援助2", kind: "life", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: 45 },
                { code: "117311", label: "生活援助3", kind: "life", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体1 + 生活 =====
                { code: "114111", label: "身体1生活1", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 20, minTotalMinutes: 40, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114211", label: "身体1生活2", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 45, minTotalMinutes: 65, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114311", label: "身体1生活3", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 70, minTotalMinutes: 90, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体2 + 生活 =====
                { code: "115111", label: "身体2生活1", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 20, minTotalMinutes: 50, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "115211", label: "身体2生活2", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 45, minTotalMinutes: 75, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "115311", label: "身体2生活3", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 70, minTotalMinutes: 100, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体3 + 生活 =====
                { code: "116111", label: "身体3生活1", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 20, minTotalMinutes: 80, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116123", label: "身体3生活2", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 45, minTotalMinutes: 105, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116135", label: "身体3生活3", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 70, minTotalMinutes: 130, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体4 + 生活 =====
                { code: "116211", label: "身体4生活1", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 20, minTotalMinutes: 110, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116223", label: "身体4生活2", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 45, minTotalMinutes: 135, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116235", label: "身体4生活3", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 70, minTotalMinutes: 160, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体5 + 生活 =====
                { code: "116311", label: "身体5生活1", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 20, minTotalMinutes: 140, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116323", label: "身体5生活2", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 45, minTotalMinutes: 165, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116335", label: "身体5生活3", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 70, minTotalMinutes: 190, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体6 + 生活 =====
                { code: "116411", label: "身体6生活1", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 20, minTotalMinutes: 170, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116423", label: "身体6生活2", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 45, minTotalMinutes: 195, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116435", label: "身体6生活3", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 70, minTotalMinutes: 220, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体7 + 生活 =====
                { code: "116511", label: "身体7生活1", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 20, minTotalMinutes: 200, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116523", label: "身体7生活2", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 45, minTotalMinutes: 225, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116535", label: "身体7生活3", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 70, minTotalMinutes: 250, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体8 + 生活 =====
                { code: "116611", label: "身体8生活1", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 20, minTotalMinutes: 230, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116623", label: "身体8生活2", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 45, minTotalMinutes: 255, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116635", label: "身体8生活3", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 70, minTotalMinutes: 280, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体9 + 生活 =====
                { code: "116711", label: "身体9生活1", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 20, minTotalMinutes: 260, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116723", label: "身体9生活2", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 45, minTotalMinutes: 285, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116735", label: "身体9生活3", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 70, minTotalMinutes: 310, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体01 + 生活 =====
                { code: "114145", label: "身体01生活1", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114169", label: "身体01生活2", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114193", label: "身体01生活3", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 70, minTotalMinutes: 70, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体02 + 生活 =====
                { code: "114601", label: "身体02生活1", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114646", label: "身体02生活2", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114658", label: "身体02生活3", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 70, minTotalMinutes: 70, maxTotalMinutes: Number.POSITIVE_INFINITY },
            ];

            /** @type {ServiceDefinition[]} */
            const SERVICE_DEFINITIONS_NIGHT = [
                // ===== 身体のみ（夜朝） =====
                { code: "111112", label: "身体介護1・夜", kind: "body", minBodyMinutes: 20, minLifeMinutes: 0, minTotalMinutes: 20, maxTotalMinutes: 30 },
                { code: "111212", label: "身体介護2・夜", kind: "body", minBodyMinutes: 30, minLifeMinutes: 0, minTotalMinutes: 30, maxTotalMinutes: 60 },
                { code: "111312", label: "身体介護3・夜", kind: "body", minBodyMinutes: 60, minLifeMinutes: 0, minTotalMinutes: 60, maxTotalMinutes: 90 },
                { code: "111412", label: "身体介護4・夜", kind: "body", minBodyMinutes: 90, minLifeMinutes: 0, minTotalMinutes: 90, maxTotalMinutes: 120 },
                { code: "111512", label: "身体介護5・夜", kind: "body", minBodyMinutes: 120, minLifeMinutes: 0, minTotalMinutes: 120, maxTotalMinutes: 150 },
                { code: "111612", label: "身体介護6・夜", kind: "body", minBodyMinutes: 150, minLifeMinutes: 0, minTotalMinutes: 150, maxTotalMinutes: 180 },
                { code: "111712", label: "身体介護7・夜", kind: "body", minBodyMinutes: 180, minLifeMinutes: 0, minTotalMinutes: 180, maxTotalMinutes: 210 },
                { code: "111812", label: "身体介護8・夜", kind: "body", minBodyMinutes: 210, minLifeMinutes: 0, minTotalMinutes: 210, maxTotalMinutes: 240 },
                { code: "111912", label: "身体介護9・夜", kind: "body", minBodyMinutes: 240, minLifeMinutes: 0, minTotalMinutes: 240, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 生活のみ（夜朝） =====
                { code: "117212", label: "生活援助2・夜", kind: "life", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: 45 },
                { code: "117312", label: "生活援助3・夜", kind: "life", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体1 + 生活（夜朝） =====
                { code: "114112", label: "身体1生活1・夜", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 20, minTotalMinutes: 40, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114212", label: "身体1生活2・夜", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 45, minTotalMinutes: 65, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114312", label: "身体1生活3・夜", kind: "combo", minBodyMinutes: 20, minLifeMinutes: 70, minTotalMinutes: 90, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体2 + 生活（夜朝） =====
                { code: "115112", label: "身体2生活1・夜", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 20, minTotalMinutes: 50, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "115212", label: "身体2生活2・夜", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 45, minTotalMinutes: 75, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "115312", label: "身体2生活3・夜", kind: "combo", minBodyMinutes: 30, minLifeMinutes: 70, minTotalMinutes: 100, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体3 + 生活（夜朝） =====
                { code: "116112", label: "身体3生活1・夜", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 20, minTotalMinutes: 80, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116124", label: "身体3生活2・夜", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 45, minTotalMinutes: 105, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116136", label: "身体3生活3・夜", kind: "combo", minBodyMinutes: 60, minLifeMinutes: 70, minTotalMinutes: 130, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体4 + 生活（夜朝） =====
                { code: "116212", label: "身体4生活1・夜", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 20, minTotalMinutes: 110, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116224", label: "身体4生活2・夜", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 45, minTotalMinutes: 135, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116236", label: "身体4生活3・夜", kind: "combo", minBodyMinutes: 90, minLifeMinutes: 70, minTotalMinutes: 160, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体5 + 生活（夜朝） =====
                { code: "116312", label: "身体5生活1・夜", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 20, minTotalMinutes: 140, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116324", label: "身体5生活2・夜", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 45, minTotalMinutes: 165, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116336", label: "身体5生活3・夜", kind: "combo", minBodyMinutes: 120, minLifeMinutes: 70, minTotalMinutes: 190, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体6 + 生活（夜朝） =====
                { code: "116412", label: "身体6生活1・夜", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 20, minTotalMinutes: 170, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116424", label: "身体6生活2・夜", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 45, minTotalMinutes: 195, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116436", label: "身体6生活3・夜", kind: "combo", minBodyMinutes: 150, minLifeMinutes: 70, minTotalMinutes: 220, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体7 + 生活（夜朝） =====
                { code: "116512", label: "身体7生活1・夜", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 20, minTotalMinutes: 200, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116524", label: "身体7生活2・夜", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 45, minTotalMinutes: 225, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116536", label: "身体7生活3・夜", kind: "combo", minBodyMinutes: 180, minLifeMinutes: 70, minTotalMinutes: 250, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体8 + 生活（夜朝） =====
                { code: "116612", label: "身体8生活1・夜", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 20, minTotalMinutes: 230, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116624", label: "身体8生活2・夜", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 45, minTotalMinutes: 255, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116636", label: "身体8生活3・夜", kind: "combo", minBodyMinutes: 210, minLifeMinutes: 70, minTotalMinutes: 280, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体9 + 生活（夜朝） =====
                { code: "116712", label: "身体9生活1・夜", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 20, minTotalMinutes: 260, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116724", label: "身体9生活2・夜", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 45, minTotalMinutes: 285, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "116736", label: "身体9生活3・夜", kind: "combo", minBodyMinutes: 240, minLifeMinutes: 70, minTotalMinutes: 310, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体01 + 生活（夜朝） =====
                { code: "114146", label: "身体01生活1・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114170", label: "身体01生活2・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114194", label: "身体01生活3・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 70, minTotalMinutes: 70, maxTotalMinutes: Number.POSITIVE_INFINITY },

                // ===== 身体02 + 生活（夜朝） =====
                { code: "114602", label: "身体02生活1・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 20, minTotalMinutes: 20, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114647", label: "身体02生活2・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 45, minTotalMinutes: 45, maxTotalMinutes: Number.POSITIVE_INFINITY },
                { code: "114659", label: "身体02生活3・夜", kind: "combo", minBodyMinutes: 0, minLifeMinutes: 70, minTotalMinutes: 70, maxTotalMinutes: Number.POSITIVE_INFINITY },
            ];

            const getActiveServiceDefinitions = () =>
                (modalNightFlag && modalNightFlag.checked ? SERVICE_DEFINITIONS_NIGHT : SERVICE_DEFINITIONS_DAY);

            /**
             * "HH:mm" 形式の開始・終了時刻から合計分数を計算する。end < start は日跨ぎとして24h加算。
             * @param {string} startTime
             * @param {string} endTime
             * @returns {number}
             */
            function calcVisitMinutes(startTime, endTime) {
                const [sH, sM] = startTime.split(':').map(Number);
                const [eH, eM] = endTime.split(':').map(Number);
                const start = sH * 60 + sM;
                let end = eH * 60 + eM;
                if (Number.isNaN(start) || Number.isNaN(end)) {
                    return 0;
                }
                if (end < start) {
                    end += 24 * 60;
                }
                return end - start;
            }

            /**
             * ケアウイング帯に合わせた候補判定:
             * - body/life: [min, max) か、境界 t === max を許容
             * - combo: minTotal を満たせば候補（上限は未チェック、TODO）
             * @param {ServiceDefinition} service
             * @param {number} visitMinutes
             */
            function isCandidateForCareWingLocal(service, visitMinutes) {
                const { kind, minTotalMinutes, maxTotalMinutes } = service;
                if (kind === 'combo') {
                    return visitMinutes >= minTotalMinutes;
                }
                if (maxTotalMinutes === Number.POSITIVE_INFINITY) {
                    return visitMinutes >= minTotalMinutes;
                }
                return (
                    (visitMinutes >= minTotalMinutes && visitMinutes < maxTotalMinutes) ||
                    visitMinutes === maxTotalMinutes
                );
            }

            /**
             * 訪問時間でケアウイング準拠のサービス候補を返す。
             * @param {string} startTime
             * @param {string} endTime
             * @param {ServiceFilterMode} mode
             * @returns {ServiceDefinition[]}
             */
            function getCandidateServicesLocal(startTime, endTime, mode = 'care') {
                const visitMinutes = calcVisitMinutes(startTime, endTime);
                const filterByMode = (svc) => {
                    switch (mode) {
                        case 'care':
                        default:
                            return svc.kind === 'body' || svc.kind === 'life' || svc.kind === 'combo';
                    }
                };
                const defs = getActiveServiceDefinitions();
                return defs
                    .filter(filterByMode)
                    .filter((svc) => isCandidateForCareWingLocal(svc, visitMinutes));
            }

            const originalServiceData = {
                '介保': {
                    '介護': {}, // Placeholder for dynamic content
                    '二人介助': { '二人介助（2人目）': 'DK0001' }
                },
                '障支': {
                    '居宅介護': { '居宅身体介護': '111000', '居宅家事援助': '112000', '通院介助（身体介護あり）': '113000', '通院介助（身体介護なし）': '114000' },
                    '重度訪介': { '重度訪問介護Ⅰ': '121000', '重度訪問介護Ⅱ': '122000', '重度訪問介護Ⅲ': '123000' },
                    '同行援護': { '同行援護': '153000' },
                    '二人介助（2人目）': { '2人介助（2人目）': 'DK0001' },
                    '移動支援1': { '移動支援': 'A11000' }
                }
            };
            // 旧実装互換: serviceData 参照が残っていても落ちないようエイリアスを定義
            const serviceData = originalServiceData;

            // 時間帯に関わらず最低限表示する介護サービスのフォールバック
            const fallbackCareServices = {
                '身体介護（基本）': 'CARE_BODY_BASIC',
                '生活援助（基本）': 'CARE_LIFE_BASIC',
                '通院介助（身体介護あり）': 'CARE_HOSPITAL_BODY',
                '通院介助（身体介護なし）': 'CARE_HOSPITAL_NO_BODY'
            };

            let currentPath = [];

            function renderDropdown(data, path = []) {
                // ★重要：完全にクリアして増殖を防ぐ
                serviceDropdown.innerHTML = '';
                let infoMessage = '';

                // 介保/介護の場合は時間帯に応じたサービスを動的に取得
                if (path.join('/') === '介保/介護') {
                    const startTime = modalStartTimeInput.value;
                    const endTime = modalEndTimeInput.value;

                    if (startTime && endTime) {
                        try {
                            const candidates = getCandidateServicesLocal(startTime, endTime, 'care');
                            let dynamicCareServices = {};
                            if (candidates.length > 0) {
                                candidates.forEach(service => {
                                    dynamicCareServices[service.label] = service.code;
                                });
                                data = dynamicCareServices;
                            } else {
                                infoMessage = 'その時間帯で適合するサービスが見つかりませんでした。フォールバック候補を表示します。';
                                data = fallbackCareServices;
                            }
                        } catch (err) {
                            console.error('サービス候補取得エラー:', err);
                            infoMessage = 'サービス候補の取得に失敗しました。フォールバック候補を表示します。';
                            data = fallbackCareServices;
                        }
                    } else {
                        infoMessage = '開始と終了時刻を入力してください。入力済みの場合は一度時間を修正してみてください。';
                        data = fallbackCareServices;
                    }
                }

                // 情報メッセージの表示
                if (infoMessage) {
                    const msg = document.createElement('div');
                    msg.style.cssText = 'padding: 12px; background: #fff8dc; color: #856404; border-bottom: 1px solid #ffc107; font-size: 12px; line-height: 1.4;';
                    msg.textContent = infoMessage;
                    serviceDropdown.appendChild(msg);
                }

                // 「戻る」ボタン（階層が深い場合のみ表示）
                if (path.length > 0) {
                    const backBtn = document.createElement('div');
                    backBtn.className = 'dropdown-back-btn';
                    backBtn.innerHTML = '<span style="font-size: 14px; margin-right: 4px;">←</span><span>戻る</span>';
                    backBtn.style.cssText = 'padding: 12px 15px; cursor: pointer; background: linear-gradient(to bottom, #f8f9fa, #e9ecef); border-bottom: 2px solid #dee2e6; font-weight: 600; color: #495057; position: sticky; top: 0; z-index: 10; display: flex; align-items: center; font-size: 13px;';
                    backBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        path.pop(); // 一つ上の階層へ
                        const parentData = path.reduce((obj, key) => obj[key] || {}, originalServiceData);
                        renderDropdown(parentData, path);
                    });
                    backBtn.addEventListener('mouseenter', () => { backBtn.style.background = 'linear-gradient(to bottom, #e9ecef, #dee2e6)'; });
                    backBtn.addEventListener('mouseleave', () => { backBtn.style.background = 'linear-gradient(to bottom, #f8f9fa, #e9ecef)'; });
                    serviceDropdown.appendChild(backBtn);
                }

                // データがない場合のメッセージ
                if (!data || Object.keys(data).length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'padding: 20px; text-align: center; color: #999; font-size: 13px;';
                    emptyMsg.textContent = 'サービスが見つかりません';
                    serviceDropdown.appendChild(emptyMsg);
                    return;
                }

                // アイテムの生成
                for (const [key, value] of Object.entries(data)) {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.style.cssText = 'padding: 12px 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; font-size: 13px; transition: all 0.2s;';

                    // 値がオブジェクトなら「カテゴリ」、文字列なら「選択項目」として扱う
                    if (typeof value === 'object' && value !== null) {
                        // --- カテゴリ（次へ） ---
                        item.innerHTML = `<span style="font-weight: 500;">${key}</span><span style="color: #999; font-size: 16px;">›</span>`;
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            path.push(key); // 下の階層へ
                            const nextData = path.reduce((obj, k) => (obj && obj[k] !== undefined ? obj[k] : {}), originalServiceData);
                            renderDropdown(nextData || {}, path);
                        });
                    } else {
                        // --- 選択項目（確定） ---
                        item.innerHTML = `<span style="font-weight: 500;">${key}</span><span style="color: #999; font-size: 11px;">${value}</span>`;
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            // 選択処理：inputに値をセットして閉じる
                            const abbr = resolveServiceAbbreviation(key, value);
                            if (serviceDisplayInput) {
                                serviceDisplayInput.value = abbr || key;
                                serviceDisplayInput.dataset.fullName = key;
                                serviceDisplayInput.dataset.code = value;
                            }
                            serviceInput.value = value;
                            serviceDropdown.style.display = 'none';
                            currentPath = [];
                        });
                    }

                    // ホバー効果
                    item.addEventListener('mouseenter', () => {
                        item.style.background = '#f8f9fa';
                        item.style.paddingLeft = '18px';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'white';
                        item.style.paddingLeft = '15px';
                    });

                    serviceDropdown.appendChild(item);
                }
            }

            document.addEventListener('serviceUtilsReady', () => {
                if (serviceDisplayInput) {
                    serviceDisplayInput.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (serviceDropdown.style.display === 'block') {
                            serviceDropdown.style.display = 'none';
                            return;
                        }
                        currentPath = [];
                        renderDropdown(originalServiceData, currentPath);
                        serviceDropdown.style.display = 'block';
                    });
                }

                const clearServiceSelection = () => {
                    if (serviceDisplayInput) {
                        serviceDisplayInput.value = '';
                        delete serviceDisplayInput.dataset.fullName;
                        delete serviceDisplayInput.dataset.code;
                    }
                    if (serviceInput) serviceInput.value = '';
                };
                const refreshCareCandidates = () => {
                    // ドロップダウン表示中かつ「介保/介護」を開いている場合のみ再描画
                    if (serviceDropdown.style.display === 'block' && currentPath.join('/') === '介保/介護') {
                        renderDropdown(originalServiceData, currentPath);
                    }
                };

                if (modalStartTimeInput) {
                    modalStartTimeInput.addEventListener('change', () => {
                        clearServiceSelection();
                        refreshCareCandidates();
                    });
                }
                if (modalEndTimeInput) {
                    modalEndTimeInput.addEventListener('change', () => {
                        clearServiceSelection();
                        refreshCareCandidates();
                    });
                }
            });

            document.addEventListener('click', (e) => {
                if (serviceDropdown && !serviceDropdown.contains(e.target) && e.target !== serviceDisplayInput) {
                    serviceDropdown.style.display = 'none';
                }
            });
            // --- END REPLACEMENT ---



            if (serviceDisplayInput) {
                serviceDisplayInput.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (serviceDropdown.style.display === 'none') {
                        currentPath = [];
                        renderDropdown(originalServiceData, currentPath);
                        serviceDropdown.style.display = 'block';
                    } else {
                        serviceDropdown.style.display = 'none';
                    }
                });
            }

            document.addEventListener('click', (e) => {
                if (serviceDropdown && !serviceDropdown.contains(e.target) && e.target !== serviceDisplayInput) {
                    serviceDropdown.style.display = 'none';
                    currentPath = [];
                }
            });

            createModalForm.addEventListener('submit', e => {
                e.preventDefault();
                const staffName = createModalStaffSearch.value.trim();
                const isBreak = createModalBreakCheckbox.checked;
                // 全角スペースを半角スペースに統一
                const userName = isBreak ? '中抜け' : createModalUserSearch.value.trim().replace(/　/g, ' ');
                const selectedDay = parseInt(createModalDateInput.value); // 入力日
                const serviceCodeInput = document.getElementById('modal-service-input');
                const serviceDisplayField = document.getElementById('modal-service-display');
                const serviceNameInput = document.getElementById('modal-service-name-input');
                const serviceCode = isBreak ? '' : serviceCodeInput.value.trim();
                const serviceAbbr = isBreak ? '' : serviceDisplayField.value.trim();
                const serviceName = isBreak ? '' : (serviceDisplayField.dataset.fullName || serviceAbbr);
                const customServiceName = isBreak ? '' : serviceNameInput.value.trim(); // 自由入力のサービス名
                const startTime = document.getElementById('modal-start-time').value;
                const endTime = document.getElementById('modal-end-time').value;

                if (!staffName) {
                    alert('担当者を入力してください。');
                    return;
                }

                // バリデーション：利用者名が空欄の場合は警告なしで許可（青色マグネットとして作成）
                // if (!isBreak && !userName) {
                //     alert('利用者を入力してください。');
                //     return;
                // }

                if (!selectedDay || selectedDay < 1 || selectedDay > 31) {
                    alert('日付（1〜31）を入力してください。');
                    return;
                }

                if (!startTime || !endTime) {
                    alert('?????????????????????');
                    return;
                }

                if (!isBreak && (!serviceName || !serviceCode)) {
                    alert('????????????????');
                    return;
                }

                // 現在表示中の年月を使用して完全な日付を作成
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1;
                const selectedDate = `${currentYear}-${String(currentMonth).padStart(2, '0')}-${String(selectedDay).padStart(2, '0')}`;

                // 日付のバリデーション（警告のみ、保存は許可）
                const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
                if (selectedDay > daysInMonth) {
                    console.warn(`注意: ${currentYear}年${currentMonth}月は${daysInMonth}日までしかありませんが、${selectedDay}日として保存します。`);
                }

                const magnetData = {
                    id: 'custom-magnet-' + Date.now(),
                    userName: userName,
                    customServiceName: customServiceName, // 自由入力のサービス名
                    serviceType: serviceAbbr,
                    serviceName: serviceName,
                    serviceCode: serviceCode,
                    time: `${startTime}-${endTime}`,
                    staff: staffName,
                    date: selectedDate
                };

                // 状態を保存（Undo用）
                saveStateToUndo();

                const newMagnet = createMagnet(magnetData);

                // 「中抜き」未チェック かつ 利用者名が空欄の場合、青色にする
                if (!isBreak && createModalUserSearch.value.trim() === '') {
                    newMagnet.classList.add('color-blue');
                }

                // 新規作成マグネットにマーカーを追加
                newMagnet.classList.add('newly-created');
                console.log('✅ 新規作成クラス追加:', {
                    hasClass: newMagnet.classList.contains('newly-created'),
                    allClasses: Array.from(newMagnet.classList),
                    magnet: newMagnet
                });

                // 選択した日付と担当者のセルに直接配置
                const selectedYear = currentYear;
                const selectedMonth = currentMonth;

                // 担当者の列インデックスを取得
                const staffIndex = staffNames.indexOf(staffName);
                if (staffIndex === -1) {
                    alert(`担当者「${staffName}」が見つかりません。担当者管理で追加してください。`);
                    return;
                }

                // 選択した日付と担当者のセルを探して配置
                const tbody = document.querySelector('#shift-table tbody');
                const targetRow = Array.from(tbody.querySelectorAll('tr')).find(row => {
                    const dateCell = row.querySelector('td:nth-child(2)');
                    if (dateCell) {
                        const dateCellText = dateCell.textContent;
                        const dayMatch = dateCellText.match(/^(\d+)\(/);
                        if (dayMatch && parseInt(dayMatch[1]) === selectedDay) {
                            return true;
                        }
                    }
                    return false;
                });

                if (targetRow) {
                    const cells = Array.from(targetRow.querySelectorAll('td.drop-zone:not(.storage-location)'));
                    const targetCell = cells[staffIndex];
                    if (targetCell) {
                        // 該当するセルに追加
                        targetCell.appendChild(newMagnet);
                        sortMagnetsInCell(targetCell);
                        updateAllHours();
                    } else {
                        // セルが見つからない場合は未割り当てに
                        unassignedBox.appendChild(newMagnet);
                    }
                } else {
                    // 行が見つからない場合は未割り当てに
                    unassignedBox.appendChild(newMagnet);
                }
                setupDragAndDrop();

                // 変更連絡を記録（新規追加）
                saveChangeNotification({
                    userName: userName,
                    date: selectedDate,
                    changeType: '新規追加',
                    staffName: staffName,
                    serviceName: serviceName,
                    details: `?????????: ${userName} ${serviceName} ${startTime}-${endTime}`,
                    time: `${startTime}-${endTime}`
                });

                // モーダルを閉じる
                createModal.classList.remove('visible');
                createModalForm.reset();
                createModalBreakCheckbox.checked = false;
                document.getElementById('modal-user-search').disabled = false;
                const serviceDisplay = document.getElementById('modal-service-display');
                if (serviceDisplay) {
                    serviceDisplay.disabled = false;
                    serviceDisplay.required = true;
                    serviceDisplay.value = '';
                }
                document.getElementById('modal-service-input').value = '';

                // リアルタイム同期用の自動保存
                console.log('🔵 新規マグネット作成完了');
                console.log('🔵 新規作成時のautoSaveMagnetPlacement存在確認:', typeof autoSaveMagnetPlacement);
                if (typeof autoSaveMagnetPlacement === 'function') {
                    console.log(`💾 新規マグネット作成後の自動保存トリガー: ${selectedDay}日`);
                    autoSaveMagnetPlacement(selectedDay);
                } else {
                    console.log('❌ 新規作成時の自動保存がスキップされました');
                }

                // Firebaseに保存（非同期）- shiftsコレクション用
                (async () => {
                    if (window.firebaseAPI && typeof window.firebaseAPI.saveShift === 'function') {
                        const shift = {
                            staff: staffName,
                            userName: userName,
                            serviceType: serviceAbbr,
                            serviceName: serviceName,
                            serviceCode: serviceCode,
                            startTime: startTime,
                            endTime: endTime,
                            time: `${startTime}-${endTime}`,
                            date: selectedDate,
                            createdAt: new Date().toISOString()
                        };
                        try {
                            await window.firebaseAPI.saveShift(shift);
                            console.log(`✓ マグネットをFirestoreのshiftsコレクションに保存しました: ${selectedDate} ${userName} ${startTime}-${endTime}`);
                        } catch (err) {
                            console.error('❌ Firebase保存エラー:', err);
                            alert('Firebaseへの保存に失敗しました。ネットワーク接続を確認してください。\nエラー: ' + err.message);
                        }
                    }
                })();
            });

            prevMonthBtn.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() - 1);
                renderMonthlyTable(currentDate.getFullYear(), currentDate.getMonth() + 1);
                loadMagnetPlacementsFromFirebase(currentDate.getFullYear(), currentDate.getMonth() + 1);
                setupRealtimeSync(); // リアルタイム同期を再設定
            });

            nextMonthBtn.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() + 1);
                renderMonthlyTable(currentDate.getFullYear(), currentDate.getMonth() + 1);
                loadMagnetPlacementsFromFirebase(currentDate.getFullYear(), currentDate.getMonth() + 1);
                setupRealtimeSync(); // リアルタイム同期を再設定
            });

            // 編集前の元の時間を保存する変数
            let originalScheduledTime = '';
            let serviceRecordUnsubscribe = null; // サービス記録のリアルタイムリスナー

            async function openRecordModal(magnet) {
                cancelCut();
                currentEditingMagnetId = magnet.id;
                const recordDetails = JSON.parse(localStorage.getItem('recordDetails')) || {};
                const savedData = recordDetails[currentEditingMagnetId] || {};

                // 元の時間を保存
                originalScheduledTime = magnet.dataset.time || '';

                document.getElementById('record-scheduled-time').value = originalScheduledTime;
                document.getElementById('record-service-content').value = magnet.dataset.service || '';
                document.getElementById('record-user').value = magnet.dataset.user || '';

                const cellIndex = magnet.closest('td').cellIndex;
                const staffName = staffNames[cellIndex - 2] || '未割り当て';
                document.getElementById('record-staff').value = staffName;

                // マグネットから日付を取得
                const row = magnet.closest('tr');
                const dateCell = row?.querySelector('td:nth-child(2)');
                let dateStr = '';
                if (dateCell) {
                    const dateCellText = dateCell.textContent;
                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                    if (dayMatch) {
                        const day = parseInt(dayMatch[1]);
                        const year = currentDate.getFullYear();
                        const month = currentDate.getMonth() + 1;
                        dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                    }
                }

                // 既存のリアルタイムリスナーを解除
                if (serviceRecordUnsubscribe) {
                    serviceRecordUnsubscribe();
                    serviceRecordUnsubscribe = null;
                }

                // サービス記録のリアルタイム監視を設定
                if (window.db && window.firestoreUtils && dateStr && magnet.dataset.user && staffName) {
                    try {
                        console.log('📡 サービス記録のリアルタイム監視開始:', {
                            date: dateStr,
                            customer: magnet.dataset.user,
                            staff: staffName
                        });

                        const { collection, query, where, onSnapshot } = window.firestoreUtils;
                        const serviceRecordsRef = collection(window.db, 'serviceRecords');
                        const q = query(
                            serviceRecordsRef,
                            where('date', '==', dateStr),
                            where('customerName', '==', magnet.dataset.user),
                            where('staffName', '==', staffName)
                        );

                        serviceRecordUnsubscribe = onSnapshot(q, (snapshot) => {
                            if (!snapshot.empty) {
                                const firebaseData = snapshot.docs[0].data();
                                console.log('🔔 サービス記録が更新されました:', firebaseData);

                                // モーダルの内容を更新
                                updateRecordModalContent(firebaseData, savedData);
                            } else {
                                console.log('📭 サービス記録なし - localStorageのデータを使用');
                                updateRecordModalContent(null, savedData);
                            }
                        }, (error) => {
                            console.error('サービス記録リアルタイム監視エラー:', error);
                        });
                    } catch (error) {
                        console.error('Firebaseからのサービス記録取得エラー:', error);
                    }
                } else {
                    // Firebaseが使えない場合はlocalStorageのデータを使用
                    updateRecordModalContent(null, savedData);
                }

                setModalReadOnly(true);
                recordModal.classList.add('visible');
            }

            // モーダルの内容を更新する関数
            function updateRecordModalContent(firebaseData, savedData) {
                if (firebaseData) {
                    document.getElementById('record-actual-time').value = firebaseData.actualDuration || '';

                    // 介護内容を構築
                    let careDetails = [];
                    if (firebaseData.body && firebaseData.body.length > 0) {
                        careDetails.push('【身体】' + firebaseData.body.join(', '));
                    }
                    if (firebaseData.housework && firebaseData.housework.length > 0) {
                        careDetails.push('【家事】' + firebaseData.housework.join(', '));
                    }
                    if (firebaseData.required && firebaseData.required.length > 0) {
                        careDetails.push('【必須】' + firebaseData.required.join(', '));
                    }
                    if (firebaseData.condition && firebaseData.condition.length > 0) {
                        careDetails.push('【様子】' + firebaseData.condition.join(', '));
                    }
                    document.getElementById('record-care-details').value = careDetails.join('\n');

                    // バイタル情報
                    let vitals = '';
                    if (firebaseData.vital) {
                        if (firebaseData.vital.temperature) {
                            vitals += `体温: ${firebaseData.vital.temperature}℃\n`;
                        }
                        if (firebaseData.vital.systolic && firebaseData.vital.diastolic) {
                            vitals += `血圧: ${firebaseData.vital.systolic}/${firebaseData.vital.diastolic} mmHg`;
                        }
                    }
                    document.getElementById('record-vitals').value = vitals;

                    document.getElementById('record-instructions').value = savedData.instructions || '';
                    document.getElementById('record-special-notes').value = firebaseData.notes || '';
                } else {
                    document.getElementById('record-actual-time').value = savedData.actualTime || '';
                    document.getElementById('record-care-details').value = savedData.careDetails || '';
                    document.getElementById('record-vitals').value = savedData.vitals || '';
                    document.getElementById('record-instructions').value = savedData.instructions || '';
                    document.getElementById('record-special-notes').value = savedData.specialNotes || '';
                }
            }

            function setModalReadOnly(isReadOnly) {
                const fields = recordModal.querySelectorAll('.modal-body input, .modal-body textarea');
                fields.forEach(field => {
                    // 予定時間も編集可能にする
                    if (field.id !== 'record-service-content' && field.id !== 'record-staff' && field.id !== 'record-user') {
                        field.readOnly = isReadOnly;
                    }
                });
                recordEditBtn.style.display = isReadOnly ? 'inline-block' : 'none';
                recordSaveBtn.textContent = isReadOnly ? '閉じる' : '保存して閉じる';
            }

            function closeRecordModal() {
                recordModal.classList.remove('visible');
                currentEditingMagnetId = null;

                // サービス記録のリアルタイムリスナーを解除
                if (serviceRecordUnsubscribe) {
                    console.log('📡 サービス記録のリアルタイム監視を停止');
                    serviceRecordUnsubscribe();
                    serviceRecordUnsubscribe = null;
                }
            }

            async function saveRecordDetails() {
                if (!currentEditingMagnetId) return;
                const recordDetails = JSON.parse(localStorage.getItem('recordDetails')) || {};

                // 編集後の時間を取得
                const newScheduledTime = document.getElementById('record-scheduled-time').value;

                recordDetails[currentEditingMagnetId] = {
                    actualTime: document.getElementById('record-actual-time').value,
                    careDetails: document.getElementById('record-care-details').value,
                    vitals: document.getElementById('record-vitals').value,
                    instructions: document.getElementById('record-instructions').value,
                    specialNotes: document.getElementById('record-special-notes').value
                };
                localStorage.setItem('recordDetails', JSON.stringify(recordDetails));

                // 時間が変更されていればマグネットをオレンジ色にし、時間を更新
                const magnet = document.getElementById(currentEditingMagnetId);
                if (magnet && newScheduledTime && newScheduledTime !== originalScheduledTime) {
                    // 時間データを更新
                    magnet.dataset.time = newScheduledTime;

                    // マグネット表示を更新
                    const userName = magnet.dataset.user;
                    const serviceType = magnet.dataset.service;
                    const serviceCode = magnet.dataset.serviceCode || '';
                    const resolvedAbbr = resolveServiceAbbreviation(magnet.dataset.serviceName || serviceType, serviceCode) || serviceType;
                    const isAccompanyStar = magnetHasAccompanyStar(magnet);
                    magnet.innerHTML = buildMagnetInnerHTML({
                        userName,
                        serviceDisplay: resolvedAbbr,
                        serviceCode,
                        time: newScheduledTime,
                        resolvedAbbr,
                        isAccompanyStar
                    });
                    magnet.dataset.isAccompanyStar = isAccompanyStar ? 'true' : 'false';

                    // 時間が変更されたことを記録
                    magnet.dataset.timeModified = 'true';

                    // オレンジ色に変更（キャンセルされていない場合のみ）
                    if (magnet.dataset.cancelled !== 'true') {
                        magnet.classList.remove('color-yellow', 'color-red', 'color-blue');
                        magnet.classList.add('color-orange');
                    }

                    // セルを再ソートして時間を更新
                    const parentCell = magnet.parentElement;
                    if (parentCell) {
                        sortMagnetsInCell(parentCell);
                        updateAllHours();

                        // 仮想スクロール用：allDaysDataを同期
                        syncCellToAllDaysData(parentCell);
                    }

                    // 履歴に追加
                    const locationName = getLocationName(parentCell);
                    const dateCell = parentCell.closest('tr')?.querySelector('td:nth-child(2)');
                    const dateText = dateCell ? dateCell.textContent : '不明';
                    addHistoryEntry(
                        `${userName} ${serviceType}`,
                        `時間変更: ${originalScheduledTime} → ${newScheduledTime}`,
                        locationName,
                        dateText
                    );

                    // 変更連絡を記録（時間変更）
                    let timeChangeDate = '';
                    if (dateCell) {
                        const dayMatch = dateCell.textContent.match(/^(\d+)\(/);
                        if (dayMatch) {
                            const day = parseInt(dayMatch[1]);
                            const year = currentDate.getFullYear();
                            const month = currentDate.getMonth() + 1;
                            timeChangeDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        }
                    }

                    saveChangeNotification({
                        userName: userName,
                        date: timeChangeDate || new Date().toISOString().split('T')[0],
                        changeType: '時間変更',
                        staffName: locationName,
                        serviceName: serviceType,
                        details: `時間変更: ${originalScheduledTime} → ${newScheduledTime}`,
                        time: newScheduledTime
                    });

                    // Firebaseのmagnet_placementsコレクションを更新
                    await updateMagnetPlacementInFirebase(magnet, timeChangeDate);
                }
            }

            // 特定のマグネットのFirebaseデータを更新する関数
            async function updateMagnetPlacementInFirebase(magnet, dateString) {
                try {
                    if (!window.firebaseAPI || !db) {
                        console.warn('Firebase未初期化: マグネット更新をスキップ');
                        return;
                    }

                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;

                    // 日付から日を取得
                    let day;
                    if (dateString && dateString.includes('-')) {
                        day = dateString.split('-')[2];
                    } else {
                        const parentCell = magnet.parentElement;
                        const row = parentCell?.closest('tr');
                        const dateCell = row?.querySelector('td:nth-child(2)');
                        if (dateCell) {
                            const dayMatch = dateCell.textContent.match(/^(\d+)\(/);
                            if (dayMatch) {
                                day = String(parseInt(dayMatch[1])).padStart(2, '0');
                            }
                        }
                    }

                    if (!day) {
                        console.warn('日付が取得できません');
                        return;
                    }

                    // 該当する日の全マグネットを収集
                    const { doc, getDoc, setDoc } = window.firebaseModules;
                    const dayDocRef = doc(db, 'magnet_placements', yearMonth, 'days', day);
                    const dayDocSnap = await getDoc(dayDocRef);

                    let placements = [];
                    if (dayDocSnap.exists()) {
                        placements = dayDocSnap.data().placements || [];
                    }

                    // 更新するマグネットを探す
                    const magnetId = magnet.id;
                    const magnetIndex = placements.findIndex(p => p.id === magnetId);

                    if (magnetIndex !== -1) {
                        // 既存のマグネットを更新
                        placements[magnetIndex] = {
                            ...placements[magnetIndex],
                            time: magnet.dataset.time,
                            timeModified: magnet.dataset.timeModified === 'true',
                            scheduledTime: magnet.dataset.scheduledTime || magnet.dataset.time
                        };
                    } else {
                        // 新規マグネットとして追加（通常はここには来ない）
                        const parentCell = magnet.parentElement;
                        const row = parentCell?.closest('tr');
                        const staffIndex = Array.from(row?.querySelectorAll('td.drop-zone:not(.storage-location)') || []).indexOf(parentCell);
                        const staffName = staffNames[staffIndex] || '不明';

                        placements.push({
                            id: magnetId,
                            userName: magnet.dataset.user,
                            serviceType: magnet.dataset.service,
                            time: magnet.dataset.time,
                            scheduledTime: magnet.dataset.scheduledTime || magnet.dataset.time,
                            date: dateString || `${yearMonth}-${day}`,
                            staff: staffName,
                            timeModified: magnet.dataset.timeModified === 'true',
                            cancelled: magnet.dataset.cancelled === 'true',
                            isNewlyCreated: magnet.dataset.newlyCreated === 'true',
                            isDateChanged: magnet.dataset.dateChanged === 'true'
                        });
                    }

                    // Firebaseに保存
                    await setDoc(dayDocRef, {
                        placements: placements,
                        updatedAt: new Date().toISOString()
                    });

                    console.log(`✅ Firebase更新完了: ${yearMonth}/days/${day} - マグネットID: ${magnetId}`);
                } catch (error) {
                    console.error('❌ Firebase更新エラー:', error);
                }
            }

            recordEditBtn.addEventListener('click', () => {
                setModalReadOnly(false);
            });

            recordSaveBtn.addEventListener('click', async () => {
                if (recordEditBtn.style.display !== 'none') {
                    closeRecordModal();
                    return;
                }
                await saveRecordDetails();
                closeRecordModal();
            });

            if (recordCancelBtn) {
                recordCancelBtn.addEventListener('click', closeRecordModal);
            }
            if (recordModal) {
                recordModal.querySelectorAll('.modal-close-btn').forEach(btn => btn.addEventListener('click', closeRecordModal));
                recordModal.addEventListener('click', e => { if (e.target === recordModal) { closeRecordModal(); } });
            }

            // 担当者リストを職種・性別で自動ソート
            function sortStaffList() {
                // ソート順の定義
                const typeOrder = {
                    '社員（管理者）': 1,
                    '課長': 1,  // 社員（管理者）と同じ優先度
                    '社員（残業あり）': 2,
                    '社員（残業なし）': 3,
                    '事務員': 4,
                    'ヘルパー（社保加入）': 5,
                    'ヘルパー（社保未加入）': 6
                };

                staffList.sort((a, b) => {
                    const aType = a.type || '';
                    const bType = b.type || '';
                    const aGender = a.gender || '';
                    const bGender = b.gender || '';

                    // 社員は性別でソート: 男→女
                    if (aType.startsWith('社員') && bType.startsWith('社員')) {
                        if (typeOrder[aType] !== typeOrder[bType]) {
                            return typeOrder[aType] - typeOrder[bType];
                        }
                        // 同じ社員種別なら性別でソート
                        if (aGender === '男' && bGender === '女') return -1;
                        if (aGender === '女' && bGender === '男') return 1;
                        return 0;
                    }

                    // 事務員
                    if (aType === '事務員' && bType !== '事務員') {
                        return bType.startsWith('社員') ? 1 : -1;
                    }
                    if (bType === '事務員' && aType !== '事務員') {
                        return aType.startsWith('社員') ? -1 : 1;
                    }

                    // ヘルパー: 男（社保加入）→男（社保未加入）→女（社保加入）→女（社保未加入）
                    if (aType.startsWith('ヘルパー') && bType.startsWith('ヘルパー')) {
                        // 性別優先
                        if (aGender === '男' && bGender === '女') return -1;
                        if (aGender === '女' && bGender === '男') return 1;
                        // 同じ性別なら社保加入優先
                        if (aGender === bGender) {
                            return typeOrder[aType] - typeOrder[bType];
                        }
                    }

                    // その他の場合
                    return typeOrder[aType] - typeOrder[bType];
                });

                // staffNamesも同期
                staffNames = staffList.map(s => s.name || s);
            }

            function renderStaffEditor() {
                staffListEditor.innerHTML = '';
                staffList.forEach((staff, index) => {
                    const name = staff.name || staff;
                    const type = staff.type || '未設定';
                    const gender = staff.gender || '未設定';

                    const li = document.createElement('li');
                    li.draggable = true;
                    li.dataset.index = index;
                    li.innerHTML = `
                    <span class="staff-name">${name}</span>
                    <span class="staff-type-display" style="font-size: 11px; padding: 2px 8px; background-color: #e8f4fd; border-radius: 4px; color: #1976d2; min-width: 100px; text-align: center;">${type}</span>
                    <span class="staff-gender-display" style="font-size: 11px; padding: 2px 8px; background-color: ${gender === '男' ? '#e3f2fd' : gender === '女' ? '#fce4ec' : '#f5f5f5'}; border-radius: 4px; color: ${gender === '男' ? '#1565c0' : gender === '女' ? '#c2185b' : '#666'}; min-width: 30px; text-align: center;">${gender}</span>
                    <button class="delete-staff-btn" data-index="${index}">削除</button>
                `;
                    staffListEditor.appendChild(li);
                });
            }

            manageStaffBtn.addEventListener('click', async () => {
                // 担当者管理を開く前にFirebaseから最新データを取得
                let fetchedHelpers = [];
                if (window.firebaseAPI && typeof window.firebaseAPI.fetchHelpers === 'function') {
                    try {
                        const helpers = await window.firebaseAPI.fetchHelpers();
                        if (helpers && helpers.length > 0) {
                            fetchedHelpers = helpers;

                            // Firebaseから取得した担当者の職種・性別情報をそのまま使用
                            // helpersは既にfetchHelpers内で「本部」除外・「社員（管理者）」→「課長」変換済み
                            const helpersMap = new Map(helpers.map(h => [h.name, h]));
                            const uniqueNames = [...new Set(helpers.map(h => h.name))];

                            staffList = uniqueNames.map(name => {
                                const helper = helpersMap.get(name);
                                return {
                                    name: name,
                                    type: helper?.type || '未設定',  // Firebaseから直接取得
                                    gender: helper?.gender || ''
                                };
                            });

                            staffNames = staffList.map(s => s.name);
                            localStorage.setItem('staffListWithInfo', JSON.stringify(staffList));
                            localStorage.setItem('staffList', JSON.stringify(staffNames));
                            console.log('担当者管理: Firebaseから最新データを取得しました（職種情報含む）');
                        }
                    } catch (err) {
                        console.error('担当者管理: Firebaseからのデータ取得エラー:', err);
                    }
                }
                renderStaffEditor();
                staffModal.classList.add('visible');

                // datalistを更新（Firebaseから取得した担当者一覧で候補を設定）
                if (typeof updateFirebaseStaffSuggestions === 'function') {
                    updateFirebaseStaffSuggestions(fetchedHelpers);
                }
            });

            // Firebase担当者データを保持（名前入力時のオートコンプリート用）
            let firebaseHelpersData = [];

            const newStaffTypeDisplay = document.getElementById('new-staff-type-display');
            const newStaffGenderDisplay = document.getElementById('new-staff-gender-display');
            const firebaseStaffSuggestions = document.getElementById('firebase-staff-suggestions');

            // 名前入力時に職種を自動入力
            newStaffNameInput.addEventListener('input', () => {
                const inputName = newStaffNameInput.value.trim();
                const matchedHelper = firebaseHelpersData.find(h => h.name === inputName);
                if (matchedHelper) {
                    // 職種を自動入力（「社員（管理者）」は「課長」に変換）
                    let jobTitle = matchedHelper.type || '';
                    if (jobTitle === '社員（管理者）') {
                        jobTitle = '課長';
                    }
                    newStaffTypeDisplay.value = jobTitle;
                    // 性別も自動入力
                    newStaffGenderDisplay.value = matchedHelper.gender || '';
                } else {
                    newStaffTypeDisplay.value = '';
                    newStaffGenderDisplay.value = '';
                }
            });

            // datalistを更新する関数
            function updateFirebaseStaffSuggestions(helpers) {
                firebaseHelpersData = helpers || [];
                firebaseStaffSuggestions.innerHTML = '';

                // 既にシフト表に追加されている担当者を除外
                const existingNames = new Set(staffList.map(s => s.name || s));

                helpers.forEach(helper => {
                    if (!existingNames.has(helper.name)) {
                        const option = document.createElement('option');
                        option.value = helper.name;
                        firebaseStaffSuggestions.appendChild(option);
                    }
                });
            }

            addNewStaffBtn.addEventListener('click', () => {
                const newName = newStaffNameInput.value.trim();
                const newType = newStaffTypeDisplay.value;
                const newGender = newStaffGenderDisplay.value;

                if (!newName) {
                    alert('担当者名を入力してください。');
                    return;
                }

                // 名前の重複チェック
                if (staffList.some(s => (s.name || s) === newName)) {
                    alert('同じ名前の担当者が既に存在します。');
                    return;
                }

                if (!newType || !newGender) {
                    alert('社員一覧に登録されている担当者名を入力してください。\n（職種と性別が自動入力されます）');
                    return;
                }

                staffList.push({
                    name: newName,
                    type: newType,
                    gender: newGender
                });

                newStaffNameInput.value = '';
                newStaffTypeDisplay.value = '';
                newStaffGenderDisplay.value = '';

                // staffNamesも同期
                staffNames = staffList.map(s => s.name || s);

                // 自動ソート
                sortStaffList();
                renderStaffEditor();

                // datalistを更新（追加した担当者を候補から除外）
                updateFirebaseStaffSuggestions(firebaseHelpersData);
            });

            staffListEditor.addEventListener('click', e => {
                if (e.target.classList.contains('delete-staff-btn')) {
                    const index = parseInt(e.target.dataset.index);
                    const staff = staffList[index];
                    const name = staff.name || staff;

                    if (confirm(`「${name}」を削除しますか？`)) {
                        staffList.splice(index, 1);
                        staffNames = staffList.map(s => s.name || s);
                        renderStaffEditor();
                    }
                }
            });

            staffListEditor.addEventListener('dragstart', e => {
                draggedStaffItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            });

            staffListEditor.addEventListener('dragend', e => {
                e.target.classList.remove('dragging');
            });

            staffListEditor.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(staffListEditor, e.clientY);
                const currentDraggable = document.querySelector('.dragging');
                if (afterElement == null) {
                    staffListEditor.appendChild(currentDraggable);
                } else {
                    staffListEditor.insertBefore(currentDraggable, afterElement);
                }
            });

            staffListEditor.addEventListener('drop', e => {
                e.preventDefault();
                const newOrder = Array.from(staffListEditor.querySelectorAll('li')).map(li => li.querySelector('.staff-name').textContent);
                staffNames = newOrder;
                renderStaffEditor();
            });

            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            function closeStaffModal() {
                staffModal.classList.remove('visible');
                // 新しい形式で保存
                localStorage.setItem('staffListWithInfo', JSON.stringify(staffList));
                // 後方互換性のため古い形式も保存
                localStorage.setItem('staffList', JSON.stringify(staffNames));
                renderMonthlyTable(currentDate.getFullYear(), currentDate.getMonth() + 1);
            }

            closeStaffModalBtn.addEventListener('click', closeStaffModal);
            staffModal.querySelector('.modal-close-btn').addEventListener('click', closeStaffModal);

            showHistoryBtn.addEventListener('click', () => {
                renderHistory();
                historyModal.classList.add('visible');
            });
            historyModal.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.addEventListener('click', () => historyModal.classList.remove('visible'));
            });

            // 変更連絡データを収集する関数
            function collectChangeNotifications() {
                const changes = [];
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach(row => {
                    const dateCell = row.querySelector('td:nth-child(2)');
                    if (!dateCell) return;

                    const dateCellText = dateCell.textContent;
                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                    if (!dayMatch) return;
                    const day = parseInt(dayMatch[1], 10);

                    // 全ての担当者セルを走査
                    const staffCells = row.querySelectorAll('td.drop-zone');
                    staffCells.forEach(cell => {
                        const staffName = cell.dataset.staff;
                        if (!staffName) return;

                        const magnets = cell.querySelectorAll('.magnet');
                        magnets.forEach(magnet => {
                            const userName = magnet.querySelector('.magnet-user')?.textContent.trim() || '';
                            const contentEl = magnet.querySelector('.magnet-content');
                            const fullText = contentEl?.textContent.trim() || '';

                            // サービス名と時間を抽出
                            const serviceMatch = fullText.match(/^([^\d]+)/);
                            const serviceName = serviceMatch ? serviceMatch[1].trim() : '';

                            let changeType = '';

                            // 4つの変更タイプを判定
                            if (magnet.classList.contains('newly-created')) {
                                changeType = '新規追加';
                            } else if (magnet.classList.contains('date-changed')) {
                                changeType = '日にち変更';
                            } else if (magnet.classList.contains('color-orange')) {
                                changeType = '時間変更';
                            } else if (magnet.classList.contains('color-red')) {
                                changeType = 'キャンセル';
                            }

                            // いずれかの変更タイプに該当する場合のみ追加
                            if (changeType) {
                                const currentMonth = document.getElementById('month-display').textContent;
                                const dateStr = `${currentMonth.replace('年', '/')}/${day}`;

                                changes.push({
                                    user: userName,
                                    date: dateStr,
                                    changeType: changeType,
                                    staff: staffName,
                                    service: serviceName,
                                    checked: false
                                });
                            }
                        });
                    });
                });

                return changes;
            }

            // 変更連絡一覧を表示する関数
            async function showChangeNotificationsModal() {
                try {
                    const modal = document.getElementById('change-notifications-modal');
                    const listElement = document.getElementById('change-notifications-list');

                    // モーダルを表示
                    modal.classList.add('visible');

                    // データを読み込み中表示
                    listElement.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px;">読み込み中...</td></tr>';

                    // Firestoreから変更連絡データを読み込み
                    const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

                    if (window.firebaseAPI && db) {
                        const { collection, getDocs, query, orderBy } = window.firebaseModules;
                        const notificationsRef = collection(db, 'changeNotifications', yearMonth, 'notifications');
                        const q = query(notificationsRef, orderBy('createdAt', 'desc'));
                        const querySnapshot = await getDocs(q);

                        if (querySnapshot.empty) {
                            listElement.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #999;">変更連絡データがありません</td></tr>';
                        } else {
                            let html = '';
                            querySnapshot.forEach((doc) => {
                                const data = doc.data();
                                const createdAt = data.createdAt ? new Date(data.createdAt).toLocaleString('ja-JP') : '-';
                                const displayDate = data.date ? data.date : '-';

                                // 変更種別に応じて色分け
                                let typeBadge = '';
                                switch (data.changeType) {
                                    case '新規追加':
                                        typeBadge = `<span style="background:#4caf50;color:white;padding:2px 6px;border-radius:3px;font-size:11px;">${data.changeType}</span>`;
                                        break;
                                    case '曜日間移動':
                                        typeBadge = `<span style="background:#2196F3;color:white;padding:2px 6px;border-radius:3px;font-size:11px;">${data.changeType}</span>`;
                                        break;
                                    case '時間変更':
                                        typeBadge = `<span style="background:#ff9800;color:white;padding:2px 6px;border-radius:3px;font-size:11px;">${data.changeType}</span>`;
                                        break;
                                    case 'キャンセル':
                                        typeBadge = `<span style="background:#f44336;color:white;padding:2px 6px;border-radius:3px;font-size:11px;">${data.changeType}</span>`;
                                        break;
                                    default:
                                        typeBadge = data.changeType || '-';
                                }

                                html += `
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 6px; white-space: nowrap;">${displayDate}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px;">${data.userName || '-'}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px; text-align: center;">${typeBadge}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px;">${data.staffName || '-'}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px;">${data.serviceName || '-'}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px; white-space: nowrap;">${data.time || '-'}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px;">${data.details || '-'}</td>
                                    <td style="border: 1px solid #ddd; padding: 6px; white-space: nowrap; font-size: 11px;">${createdAt}</td>
                                </tr>
                            `;
                            });
                            listElement.innerHTML = html;
                        }
                    } else {
                        listElement.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #f44336;">Firebaseが初期化されていません</td></tr>';
                    }

                    // モーダルを閉じるイベント
                    modal.querySelectorAll('.modal-close-btn').forEach(btn => {
                        btn.onclick = () => modal.classList.remove('visible');
                    });
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) modal.classList.remove('visible');
                    });

                } catch (error) {
                    console.error('変更連絡一覧の表示エラー:', error);
                    const listElement = document.getElementById('change-notifications-list');
                    listElement.innerHTML = `<tr><td colspan="8" style="text-align: center; padding: 20px; color: #f44336;">エラー: ${error.message}</td></tr>`;
                }
            }

            // 変更連絡ボタンのイベントハンドラ
            changeNotificationBtn.addEventListener('click', () => {
                // 変更連絡一覧を別タブで開く
                window.open('changeNotifications.html', '_blank');
            });

            // 月間シフトデータを収集する関数（Firebaseから直接取得）
            async function collectMonthlyShiftData() {
                console.log('=== 月間シフトデータ収集開始（Firebase） ===');

                if (!db) {
                    console.error('❌ Firebaseが初期化されていません');
                    return null;
                }

                // Firebaseモジュールを取得
                const { collection, getDocs, doc, getDoc } = window.firebaseModules;
                if (!collection || !getDocs) {
                    console.error('❌ Firebaseモジュールが利用できません');
                    return null;
                }

                try {
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;
                    const daysInMonth = new Date(year, month, 0).getDate();

                    console.log(`📅 対象月: ${yearMonth} (${daysInMonth}日間)`);

                    // 1. riyousyaコレクションから全利用者を取得
                    console.log('🔍 Step 1: riyousyaコレクションから利用者情報を取得...');
                    const riyousyaRef = collection(db, 'riyousya', 'data', 'users');
                    const riyousyaSnapshot = await getDocs(riyousyaRef);
                    const allUsers = {};
                    riyousyaSnapshot.forEach(doc => {
                        const data = doc.data();
                        if (data.name) {
                            allUsers[doc.id] = data.name;
                        }
                    });
                    console.log(`✅ 利用者情報: ${Object.keys(allUsers).length}人取得`);

                    // 2. weeklyShiftMagnetsから曜日ごとのテンプレート回数を取得
                    console.log('🔍 Step 2: weeklyShiftMagnetsから曜日ごとのテンプレート回数を取得...');
                    const weeklyMagnetsRef = collection(db, 'weeklyShiftMagnets');
                    const weeklyMagnetsSnapshot = await getDocs(weeklyMagnetsRef);

                    console.log(`📊 weeklyShiftMagnetsドキュメント数: ${weeklyMagnetsSnapshot.size}`);

                    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const dayNamesJP = ['日', '月', '火', '水', '木', '金', '土'];
                    const templateCountsByDay = {};  // 曜日ごとのテンプレート回数

                    // 各曜日の初期化
                    dayNames.forEach(day => {
                        templateCountsByDay[day] = {};
                    });

                    // 各曜日のドキュメントを処理
                    weeklyMagnetsSnapshot.forEach(docSnap => {
                        const data = docSnap.data();
                        const dayName = docSnap.id;  // Sunday, Monday, Tuesday, etc.

                        console.log(`  📅 ${dayName}: ${data.magnets ? data.magnets.length : 0}個のマグネット`);

                        // 各曜日のmagnets配列を処理
                        if (data.magnets && Array.isArray(data.magnets)) {
                            data.magnets.forEach((magnet) => {
                                const userName = magnet.userName || magnet.利用者名;
                                if (userName && userName !== '中抜け') {
                                    if (!templateCountsByDay[dayName][userName]) {
                                        templateCountsByDay[dayName][userName] = 0;
                                    }
                                    templateCountsByDay[dayName][userName]++;
                                }
                            });
                        }
                    });

                    console.log(`✅ 曜日ごとのテンプレート情報取得完了`);
                    dayNames.forEach(day => {
                        const count = Object.keys(templateCountsByDay[day]).length;
                        console.log(`  ${day}: ${count}人分`);
                    });

                    // 3. magnet_placementsから曜日ごとの実際の回数を取得
                    console.log('🔍 Step 3: magnet_placementsから曜日ごとの実際の回数を取得...');
                    const actualCountsByDay = {};  // 曜日ごとの実際の回数
                    const userStaff = {};

                    // 各曜日の初期化
                    dayNames.forEach(day => {
                        actualCountsByDay[day] = {};
                    });

                    for (let day = 1; day <= daysInMonth; day++) {
                        const dayStr = String(day).padStart(2, '0');
                        const dayDocRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'days', dayStr);
                        const dayDoc = await getDoc(dayDocRef);

                        if (dayDoc.exists()) {
                            const data = dayDoc.data();
                            if (data.placements && Array.isArray(data.placements)) {
                                data.placements.forEach(placement => {
                                    const userName = placement.userName || placement.利用者名;
                                    const staffName = placement.staff || placement.担当者名;
                                    const dateStr = `${yearMonth}-${dayStr}`;

                                    if (userName && userName !== '中抜け') {
                                        // 日付から曜日を判定
                                        const date = new Date(dateStr);
                                        const dayOfWeek = date.getDay();  // 0=日曜, 1=月曜, ...
                                        const dayNameEN = dayNames[dayOfWeek];

                                        // 曜日ごとの実際の回数をカウント
                                        if (!actualCountsByDay[dayNameEN][userName]) {
                                            actualCountsByDay[dayNameEN][userName] = 0;
                                        }
                                        actualCountsByDay[dayNameEN][userName]++;

                                        // 担当者情報を収集
                                        if (staffName) {
                                            if (!userStaff[userName]) {
                                                userStaff[userName] = [];
                                            }
                                            if (!userStaff[userName].includes(staffName)) {
                                                userStaff[userName].push(staffName);
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }

                    console.log(`✅ 曜日ごとの実際の回数取得完了`);
                    dayNames.forEach(day => {
                        const count = Object.keys(actualCountsByDay[day]).length;
                        console.log(`  ${day}: ${count}人分`);
                    });
                    console.log('担当者情報:', userStaff);

                    // 全利用者のリストを作成（riyousyaコレクションの全利用者）
                    const allUserNames = Object.values(allUsers);  // 全利用者名の配列
                    console.log(`📊 riyousyaコレクション利用者数: ${allUserNames.length}人`);

                    console.log('=== 月間シフトデータ収集完了 ===');

                    return {
                        allUsers: allUserNames,                  // riyousyaコレクションの全利用者名
                        templateCountsByDay: templateCountsByDay,  // 曜日ごとのテンプレート回数
                        actualCountsByDay: actualCountsByDay,      // 曜日ごとの実際の回数
                        userStaff: userStaff,                      // 担当者情報
                        dayNames: dayNames,                        // 曜日名（英語）
                        dayNamesJP: dayNamesJP,                    // 曜日名（日本語）
                        month: `${year}年${month}月`
                    };

                } catch (error) {
                    console.error('❌ データ収集エラー:', error);
                    throw error;
                }
            }

            // 月全体のマグネットデータを読み込む関数
            async function loadAllMagnetsForMonth() {
                console.log('🔄 月全体のマグネットデータを読み込みます...');

                try {
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;
                    const daysInMonth = new Date(year, month, 0).getDate();

                    console.log(`📅 読み込み対象: ${yearMonth} (${daysInMonth}日間)`);
                    console.log(`🔍 currentDate:`, currentDate);

                    if (window.firebaseAPI && typeof window.firebaseAPI.loadMagnetPlacements === 'function') {
                        console.log(`🔄 loadMagnetPlacements関数を呼び出します: yearMonth=${yearMonth}, startDay=1, endDay=${daysInMonth}`);

                        // 月全体（1日から月末まで）のマグネットを読み込み
                        const placements = await window.firebaseAPI.loadMagnetPlacements(yearMonth, 1, daysInMonth);

                        console.log(`📦 loadMagnetPlacementsから返されたデータ:`, placements);
                        console.log(`📊 データ数: ${placements ? placements.length : 0}`);

                        if (placements && placements.length > 0) {
                            console.log(`✅ ${placements.length}個のマグネット配置データを読み込みました`);
                            console.log(`🔍 最初の3件のデータサンプル:`, placements.slice(0, 3));

                            applyPlacementsToTable(placements);

                            // 全ての行をレンダリング済みにマーク
                            const allRows = table.querySelectorAll('tbody tr:not(.week-summary-row)');
                            console.log(`📝 ${allRows.length}行をレンダリング済みとしてマークします`);
                            allRows.forEach(row => {
                                row.dataset.rendered = 'true';
                            });

                            updateAllHours();
                            fixExistingMagnetStructure();
                            console.log(`✅ マグネット配置とDOM更新が完了しました`);
                        } else {
                            console.warn('⚠️ マグネット配置データが見つかりませんでした');
                            console.warn(`⚠️ Firebaseパス: magnet_placements/${yearMonth}/days/01~${String(daysInMonth).padStart(2, '0')}`);
                        }

                        // 未割り当てBOXも読み込み
                        const { doc, getDoc } = window.firestoreUtils;
                        const unassignedDocRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'days', 'unassigned');
                        const unassignedDoc = await getDoc(unassignedDocRef);
                        if (unassignedDoc.exists()) {
                            const unassignedData = unassignedDoc.data();
                            if (unassignedData.placements && unassignedData.placements.length > 0) {
                                applyPlacementsToTable(unassignedData.placements);
                            }
                        }
                    } else {
                        console.error('❌ firebaseAPIが利用できません');
                    }
                } catch (error) {
                    console.error('❌ マグネット読み込みエラー:', error);
                    throw error;
                }
            }

            // チェックリストボタンのイベントハンドラ
            if (checklistBtn) {
                console.log('✅ チェックリストボタンが見つかりました。イベントリスナーを登録します。');
                checklistBtn.addEventListener('click', async () => {
                    console.log('🔵 チェックリストボタンがクリックされました');
                    try {
                        // Firebaseから月間シフトデータを収集
                        const monthlyData = await collectMonthlyShiftData();
                        console.log('収集したデータ:', monthlyData);

                        // データが空でないか確認
                        if (!monthlyData) {
                            console.warn('⚠️ 警告: 収集したデータがnullです');
                            alert('データの収集に失敗しました。');
                            return;
                        }

                        // localStorageに保存
                        localStorage.setItem('monthlyShiftData', JSON.stringify(monthlyData));
                        console.log('✅ localStorageに保存しました');

                        // 別タブでチェックリスト画面を開く
                        window.open('monthlyShiftsChecklist.html', '_blank');
                    } catch (error) {
                        console.error('❌ エラーが発生しました:', error);
                        alert('データの収集中にエラーが発生しました: ' + error.message);
                    }
                });
            } else {
                console.error('❌ チェックリストボタンが見つかりません。ボタンID: checklistBtn');
            }

            // マグネット配置情報を収集する関数
            function collectMagnetPlacements() {
                const placements = [];
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach(row => {
                    const dateCell = row.querySelector('td:nth-child(2)');
                    if (!dateCell) return;

                    const dateCellText = dateCell.textContent; // 例: "22(火)"
                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                    if (!dayMatch) return;

                    const day = parseInt(dayMatch[1]);
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    const date = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                    // 各担当者のセルを確認
                    staffNames.forEach((staffName, index) => {
                        const cell = row.querySelector(`td:nth-child(${index + 3})`);
                        if (!cell) return;

                        const magnets = cell.querySelectorAll('.magnet');
                        magnets.forEach(magnet => {
                            const colorClass = getMagnetColorClass(magnet);
                            const accompanyPair = magnet.dataset.accompanyPair || '';
                            placements.push({
                                id: magnet.id,
                                date: date,
                                staff: staffName,
                                userName: magnet.dataset.user,
                                serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                                serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                                serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                                time: magnet.dataset.time,
                                durationMinutes: magnet.dataset.durationMinutes,
                                isAccompanyStar: magnetHasAccompanyStar(magnet),
                                colorClass,
                                accompanyPair,
                                cancelled: magnet.dataset.cancelled === 'true' || magnet.classList.contains('color-red'),
                                isAccompany: magnet.dataset.isAccompany === 'true' || magnet.classList.contains('color-yellow'),
                                timeModified: magnet.dataset.timeModified === 'true',
                                isNewlyCreated: magnet.dataset.isNewlyCreated === 'true',
                                isDateChanged: magnet.classList.contains('date-changed'),
                                isCompanyBurden: magnet.classList.contains('company-burden')
                            });
                        });
                    });

                    // 保管場所のセルも確認
                    const storageCell = row.querySelector('td:nth-child(1)');
                    if (storageCell) {
                        const magnets = storageCell.querySelectorAll('.magnet');
                        magnets.forEach(magnet => {
                            const colorClass = getMagnetColorClass(magnet);
                            const accompanyPair = magnet.dataset.accompanyPair || '';
                            placements.push({
                                id: magnet.id,
                                date: date,
                                staff: '保管場所',
                                userName: magnet.dataset.user,
                                serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                                serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                                serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                                time: magnet.dataset.time,
                                durationMinutes: magnet.dataset.durationMinutes,
                                isAccompanyStar: magnetHasAccompanyStar(magnet),
                                colorClass,
                                accompanyPair,
                                cancelled: magnet.dataset.cancelled === 'true' || magnet.classList.contains('color-red'),
                                isAccompany: magnet.dataset.isAccompany === 'true' || magnet.classList.contains('color-yellow'),
                                timeModified: magnet.dataset.timeModified === 'true',
                                isNewlyCreated: magnet.dataset.isNewlyCreated === 'true',
                                isDateChanged: magnet.classList.contains('date-changed'),
                                isCompanyBurden: magnet.classList.contains('company-burden')
                            });
                        });
                    }
                });

                // 未割り当てBOXのマグネットも収集
                const unassignedMagnets = unassignedBox.querySelectorAll('.magnet');
                unassignedMagnets.forEach(magnet => {
                    const colorClass = getMagnetColorClass(magnet);
                    const accompanyPair = magnet.dataset.accompanyPair || '';
                    placements.push({
                        id: magnet.id,
                        date: null,
                        staff: '未割り当て',
                        userName: magnet.dataset.user,
                        serviceType: magnet.dataset.serviceName || magnet.dataset.service,
                        serviceName: magnet.dataset.serviceName || magnet.dataset.service,
                        serviceCode: magnet.dataset.serviceCode || (/^[A-Za-z0-9]{6}$/.test(magnet.dataset.service || '') ? magnet.dataset.service : ''),
                        time: magnet.dataset.time,
                        durationMinutes: magnet.dataset.durationMinutes,
                        isAccompanyStar: magnetHasAccompanyStar(magnet),
                        colorClass,
                        accompanyPair,
                        cancelled: magnet.dataset.cancelled === 'true' || magnet.classList.contains('color-red'),
                        isAccompany: magnet.dataset.isAccompany === 'true' || magnet.classList.contains('color-yellow'),
                        timeModified: magnet.dataset.timeModified === 'true',
                        isNewlyCreated: magnet.dataset.isNewlyCreated === 'true',
                        isDateChanged: magnet.classList.contains('date-changed'),
                        isCompanyBurden: magnet.classList.contains('company-burden')
                    });
                });

                return placements;
            }

            // 自動保存インジケーターの更新
            function updateAutoSaveIndicator(status) {
                if (!autoSaveIndicator) return;

                if (status === 'saving') {
                    autoSaveIndicator.textContent = '💾 保存中...';
                    autoSaveIndicator.style.background = '#ffc107';
                } else if (status === 'saved') {
                    autoSaveIndicator.textContent = '✓ 自動保存済み';
                    autoSaveIndicator.style.background = '#28a745';
                } else if (status === 'error') {
                    autoSaveIndicator.textContent = '⚠ 保存エラー';
                    autoSaveIndicator.style.background = '#dc3545';
                }
            }

            // 自動保存は autoSaveMagnetPlacement 関数で実行されます
            // 手動保存ボタンは削除されました

            // 週間シフトからのデータを読み込んで月間シフトに反映する関数
            // loadMonthlyShiftFromWeekly関数は削除しました
            // 週間シフトからの反映はmagnet_placementsコレクションに直接保存されるため不要

            // Firebaseからマグネット配置を読み込んで復元する関数
            // 初期表示範囲のみ読み込み（パフォーマンス改善）
            async function loadMagnetPlacementsFromFirebase(year, month) {
                try {
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;
                    const daysInMonth = new Date(year, month, 0).getDate();

                    // magnet_placementsコレクションから読み込む
                    console.log('📖 magnet_placementsコレクションから読み込みます');

                    // 初期表示日: 10月は17日、それ以外は今日または月の中央
                    let currentDay;
                    const today = new Date();
                    if (month === 10) {
                        currentDay = 17; // 10月は常に17日を中心に表示
                    } else if (year === today.getFullYear() && month === today.getMonth() + 1) {
                        currentDay = today.getDate();
                    } else {
                        currentDay = Math.floor(daysInMonth / 2);
                    }

                    // 初期表示範囲: 基準日±3日 - パフォーマンス改善
                    const initialStartDay = Math.max(1, currentDay - 3);
                    const initialEndDay = Math.min(daysInMonth, currentDay + 3);

                    if (window.firebaseAPI && typeof window.firebaseAPI.loadMagnetPlacements === 'function') {
                        // 初期表示範囲のみ読み込み
                        const placements = await window.firebaseAPI.loadMagnetPlacements(yearMonth, initialStartDay, initialEndDay);

                        if (placements && placements.length > 0) {
                            applyPlacementsToTable(placements);

                            // setupDragAndDropはrenderMonthlyTableで既に呼ばれているので不要（重複呼び出し防止）
                            updateAllHours();

                            // 既存のマグネット構造を修正
                            setTimeout(() => {
                                fixExistingMagnetStructure();
                            }, 100);

                            log('マグネット配置を復元しました（初期範囲）:', initialStartDay, '-', initialEndDay, '日');
                        }

                        // 未割り当てBOXも読み込み
                        const { doc, getDoc } = window.firestoreUtils;
                        const unassignedDocRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'days', 'unassigned');
                        const unassignedDoc = await getDoc(unassignedDocRef);
                        if (unassignedDoc.exists()) {
                            const unassignedData = unassignedDoc.data();
                            if (unassignedData.placements && unassignedData.placements.length > 0) {
                                applyPlacementsToTable(unassignedData.placements);
                            }
                        }

                        // セルの状態（公休・有給・特休）を読み込み
                        await loadCellStatesFromFirebase(year, month);
                    }
                } catch (err) {
                    console.error('読み込みエラー:', err);
                }
            }

            // セルの状態を読み込む関数
            async function loadCellStatesFromFirebase(year, month) {
                try {
                    const yearMonth = `${year}-${String(month).padStart(2, '0')}`;
                    console.log('📥 セル状態の読み込みを開始...', yearMonth);

                    if (db) {
                        const { doc, getDoc } = window.firestoreUtils;
                        // magnet_placements/YYYY-MM/cell_states/data から読み込み
                        const cellStatesRef = doc(db, MAGNET_PLACEMENTS, yearMonth, 'cell_states', 'data');
                        const cellStatesDoc = await getDoc(cellStatesRef);

                        if (cellStatesDoc.exists()) {
                            const data = cellStatesDoc.data();
                            const cellStates = data.states || {};

                            // セルの状態を適用
                            Object.entries(cellStates).forEach(([date, staffStates]) => {
                                const dateObj = new Date(date);
                                const day = dateObj.getDate();

                                // 該当する行を見つける
                                const rows = document.querySelectorAll('#shift-table tbody tr:not(.week-summary-row)');
                                for (const row of rows) {
                                    const dateCell = row.querySelector('td:nth-child(2)');
                                    if (!dateCell) continue;

                                    const dateCellText = dateCell.textContent;
                                    const dayMatch = dateCellText.match(/^(\d+)\(/);
                                    if (dayMatch && parseInt(dayMatch[1]) === day) {
                                        // 各担当者のセルに状態を適用
                                        Object.entries(staffStates).forEach(([staffName, cellType]) => {
                                            const staffIndex = staffNames.indexOf(staffName);
                                            if (staffIndex !== -1) {
                                                const cell = row.querySelector(`td:nth-child(${staffIndex + 3})`);
                                                if (cell) {
                                                    const normalizedCellType = (() => {
                                                        if (typeof cellType === 'string') return cellType.trim();
                                                        if (cellType && typeof cellType === 'object' && 'type' in cellType) return String(cellType.type).trim();
                                                        return '';
                                                    })();

                                                    cell.classList.remove('cell-koukyu', 'cell-yuukyu', 'cell-tokkyu');
                                                    cell.style.backgroundColor = '';

                                                    if (normalizedCellType === 'koukyu' || normalizedCellType === 'yuukyu' || normalizedCellType === 'tokkyu') {
                                                        cell.classList.add(`cell-${normalizedCellType}`);
                                                        // インラインスタイルで背景色を設定
                                                        if (normalizedCellType === 'koukyu') {
                                                            cell.style.backgroundColor = '#c8e6c9';
                                                        } else if (normalizedCellType === 'yuukyu') {
                                                            cell.style.backgroundColor = '#ffe0b2';
                                                        } else if (normalizedCellType === 'tokkyu') {
                                                            cell.style.backgroundColor = '#e3f2fd';
                                                        }
                                                    } else {
                                                        console.warn('未知のセル状態をスキップ:', cellType);
                                                    }
                                                }
                                            }
                                        });
                                        break;
                                    }
                                }
                            });

                            // 公休・有給・特休のカウントを更新
                            updateLeaveCount();
                            console.log('✅ セル状態を復元しました:', yearMonth);
                        } else {
                            console.log('ℹ️ セル状態データが見つかりません:', yearMonth);
                        }
                    } else {
                        console.error('❌ Firebaseが初期化されていません');
                    }
                } catch (err) {
                    console.error('❌ セル状態読み込みエラー:', err);
                }
            }

            // ========================================
            // リアルタイム同期: リモート更新受信
            // ========================================

            // リモートからの変更を受信して反映する関数
            // 差分適用版: DOM全削除せず、追加/更新/削除のみ実行（パフォーマンス改善）
            function updateTableFromRemote(day, data) {
                if (!data || !data.placements) {
                    console.log(`⚠️ updateTableFromRemote: データなし (day: ${day})`);
                    return;
                }

                console.log(`🔄 updateTableFromRemote: ${day}日の変更を反映 (${data.placements.length}件)`);
                console.log('🔄 受信したマグネット:', data.placements.map(p => ({
                    id: p.id,
                    staff: p.staff,
                    userName: p.userName
                })));

                try {
                    isUpdatingFromRemote = true;

                    if (day === 'unassigned') {
                        // 未割り当てBOXを差分更新
                        const existingMagnets = unassignedBox.querySelectorAll('.magnet');
                        const existingIds = new Set(Array.from(existingMagnets).map(m => m.id));
                        const newIds = new Set(data.placements.map(p => p.id));

                        // 削除されたマグネットを削除
                        existingMagnets.forEach(magnet => {
                            if (!newIds.has(magnet.id)) {
                                magnet.remove();
                            }
                        });

                        // 新しいマグネットを追加、既存のものは会社負担クラスを更新
                        data.placements.forEach(placement => {
                            if (!existingIds.has(placement.id)) {
                                // 新規追加
                                const magnetData = {
                                    id: placement.id,
                                    userName: placement.userName,
                                    serviceType: placement.serviceType,
                                    time: placement.time,
                                    duration: placement.durationMinutes,
                                    isAccompanyStar: placement.isAccompanyStar || (placement.userName || '').startsWith('★'),
                                    isCompanyBurden: placement.isCompanyBurden,
                                    colorClass: placement.colorClass || '',
                                    accompanyPair: placement.accompanyPair || '',
                                    isNewlyCreated: placement.isNewlyCreated || false,
                                    isDateChanged: placement.isDateChanged || false
                                };
                                const magnet = createMagnet(magnetData);
                                unassignedBox.appendChild(magnet);
                            } else {
                                // 既存マグネットのクラスを更新
                                const existingMagnet = unassignedBox.querySelector(`#${placement.id}`);
                                if (existingMagnet) {
                                    const placementHasStar = placement.isAccompanyStar || (placement.userName || '').startsWith('★');
                                    const resolvedAbbr = resolveServiceAbbreviation(placement.serviceName || placement.serviceType || existingMagnet.dataset.service, placement.serviceCode || existingMagnet.dataset.serviceCode || '') || placement.serviceType;
                                    existingMagnet.dataset.isAccompanyStar = placementHasStar ? 'true' : 'false';
                                    existingMagnet.dataset.time = placement.time;
                                    existingMagnet.dataset.service = placement.serviceType || existingMagnet.dataset.service;
                                    existingMagnet.dataset.serviceName = placement.serviceName || existingMagnet.dataset.serviceName || placement.serviceType || '';
                                    existingMagnet.dataset.serviceCode = placement.serviceCode || existingMagnet.dataset.serviceCode || '';
                                    if (placement.colorClass) {
                                        applyColorClass(existingMagnet, placement.colorClass);
                                    }
                                    if (placement.accompanyPair) {
                                        existingMagnet.dataset.accompanyPair = placement.accompanyPair;
                                    } else {
                                        delete existingMagnet.dataset.accompanyPair;
                                    }
                                    existingMagnet.innerHTML = buildMagnetInnerHTML({
                                        userName: placement.userName,
                                        serviceDisplay: placement.serviceName || placement.serviceType || existingMagnet.dataset.service,
                                        serviceCode: placement.serviceCode || existingMagnet.dataset.serviceCode || '',
                                        time: placement.time,
                                        resolvedAbbr,
                                        isAccompanyStar: placementHasStar
                                    });

                                    // 会社負担クラス
                                    if (placement.isCompanyBurden) {
                                        if (!existingMagnet.classList.contains('company-burden')) {
                                            existingMagnet.classList.add('company-burden');
                                        }
                                        // インラインスタイルで確実に色を設定
                                        existingMagnet.style.backgroundColor = '#9370db';
                                        existingMagnet.style.color = 'white';
                                        const userSpan = existingMagnet.querySelector('.magnet-user');
                                        const contentSpan = existingMagnet.querySelector('.magnet-content');
                                        if (userSpan) userSpan.style.color = 'white';
                                        if (contentSpan) contentSpan.style.color = 'white';
                                    } else {
                                        existingMagnet.classList.remove('company-burden');
                                        // インラインスタイルを削除
                                        existingMagnet.style.backgroundColor = '';
                                        existingMagnet.style.color = '';
                                        const userSpan = existingMagnet.querySelector('.magnet-user');
                                        const contentSpan = existingMagnet.querySelector('.magnet-content');
                                        if (userSpan) userSpan.style.color = '';
                                        if (contentSpan) contentSpan.style.color = '';
                                    }

                                    // 新規作成マーカー
                                    if (placement.isNewlyCreated) {
                                        existingMagnet.classList.add('newly-created');
                                    } else {
                                        existingMagnet.classList.remove('newly-created');
                                    }

                                    // 日付変更マーカー
                                    if (placement.isDateChanged) {
                                        existingMagnet.classList.add('date-changed');
                                    } else {
                                        existingMagnet.classList.remove('date-changed');
                                    }
                                }
                            }
                        });
                    } else {
                        // 特定の日の行を差分更新（最適化: data-day-number属性で直接検索）
                        const dayNumber = parseInt(day);
                        const row = table.querySelector(`tbody tr[data-day-number="${dayNumber}"]`);

                        if (!row) {
                            log(`行が見つかりません: ${dayNumber}日`);
                            return;
                        }

                        // 該当行の全セルからマグネットIDを収集
                        const cells = row.querySelectorAll('.drop-zone');
                        const existingMagnets = new Map(); // id -> {magnet, cell}
                        const affectedCells = new Set();

                        cells.forEach(cell => {
                            const magnets = cell.querySelectorAll('.magnet');
                            magnets.forEach(magnet => {
                                existingMagnets.set(magnet.id, { magnet, cell });
                            });
                        });

                        // リモートデータのIDセットを作成
                        const remoteMagnetIds = new Set(data.placements.map(p => p.id));

                        // 削除: リモートにないマグネットを削除
                        existingMagnets.forEach((value, id) => {
                            if (!remoteMagnetIds.has(id)) {
                                value.magnet.remove();
                                affectedCells.add(value.cell);
                            }
                        });

                        // 追加・移動: リモートのマグネットを配置
                        data.placements.forEach(placement => {
                            let targetCell = null;
                            if (placement.staff === '保管場所') {
                                targetCell = row.querySelector('td:nth-child(1)');
                            } else if (placement.staff !== '未割り当て') {
                                const staffIndex = staffNames.indexOf(placement.staff);
                                if (staffIndex !== -1) {
                                    targetCell = row.querySelector(`td:nth-child(${staffIndex + 3})`);
                                }
                            }

                            if (targetCell) {
                                const existing = existingMagnets.get(placement.id);

                                if (!existing) {
                                    // 新規追加
                                    const magnetData = {
                                        id: placement.id,
                                        userName: placement.userName,
                                        serviceType: placement.serviceType,
                                        time: placement.time,
                                        duration: placement.durationMinutes,
                                        isAccompanyStar: placement.isAccompanyStar || (placement.userName || '').startsWith('★'),
                                        isCompanyBurden: placement.isCompanyBurden,
                                        colorClass: placement.colorClass || '',
                                        accompanyPair: placement.accompanyPair || '',
                                        isNewlyCreated: placement.isNewlyCreated || false,
                                        isDateChanged: placement.isDateChanged || false
                                    };
                                    const magnet = createMagnet(magnetData);
                                    targetCell.appendChild(magnet);
                                    affectedCells.add(targetCell);
                                } else {
                                    // 既存マグネットのクラスを更新
                                    const placementHasStar = placement.isAccompanyStar || (placement.userName || '').startsWith('★');
                                    const resolvedAbbr = resolveServiceAbbreviation(placement.serviceName || placement.serviceType || existing.magnet.dataset.service, placement.serviceCode || existing.magnet.dataset.serviceCode || '') || placement.serviceType;
                                    existing.magnet.dataset.isAccompanyStar = placementHasStar ? 'true' : 'false';
                                    existing.magnet.dataset.time = placement.time;
                                    existing.magnet.dataset.service = placement.serviceType || existing.magnet.dataset.service;
                                    existing.magnet.dataset.serviceName = placement.serviceName || existing.magnet.dataset.serviceName || placement.serviceType || '';
                                    existing.magnet.dataset.serviceCode = placement.serviceCode || existing.magnet.dataset.serviceCode || '';
                                    if (placement.colorClass) {
                                        applyColorClass(existing.magnet, placement.colorClass);
                                    }
                                    if (placement.accompanyPair) {
                                        existing.magnet.dataset.accompanyPair = placement.accompanyPair;
                                    } else {
                                        delete existing.magnet.dataset.accompanyPair;
                                    }
                                    existing.magnet.innerHTML = buildMagnetInnerHTML({
                                        userName: placement.userName,
                                        serviceDisplay: placement.serviceName || placement.serviceType || existing.magnet.dataset.service,
                                        serviceCode: placement.serviceCode || existing.magnet.dataset.serviceCode || '',
                                        time: placement.time,
                                        resolvedAbbr,
                                        isAccompanyStar: placementHasStar
                                    });

                                    // 会社負担クラス
                                    if (placement.isCompanyBurden) {
                                        if (!existing.magnet.classList.contains('company-burden')) {
                                            existing.magnet.classList.add('company-burden');
                                        }
                                        // インラインスタイルで確実に色を設定
                                        existing.magnet.style.backgroundColor = '#9370db';
                                        existing.magnet.style.color = 'white';
                                        const userSpan = existing.magnet.querySelector('.magnet-user');
                                        const contentSpan = existing.magnet.querySelector('.magnet-content');
                                        if (userSpan) userSpan.style.color = 'white';
                                        if (contentSpan) contentSpan.style.color = 'white';
                                    } else {
                                        existing.magnet.classList.remove('company-burden');
                                        // インラインスタイルを削除
                                        existing.magnet.style.backgroundColor = '';
                                        existing.magnet.style.color = '';
                                        const userSpan = existing.magnet.querySelector('.magnet-user');
                                        const contentSpan = existing.magnet.querySelector('.magnet-content');
                                        if (userSpan) userSpan.style.color = '';
                                        if (contentSpan) contentSpan.style.color = '';
                                    }

                                    // 新規作成マーカー
                                    if (placement.isNewlyCreated) {
                                        existing.magnet.classList.add('newly-created');
                                    } else {
                                        existing.magnet.classList.remove('newly-created');
                                    }

                                    // 日付変更マーカー
                                    if (placement.isDateChanged) {
                                        existing.magnet.classList.add('date-changed');
                                    } else {
                                        existing.magnet.classList.remove('date-changed');
                                    }

                                    if (existing.cell !== targetCell) {
                                        // 移動（セル間の移動）
                                        targetCell.appendChild(existing.magnet);
                                        affectedCells.add(existing.cell);
                                        affectedCells.add(targetCell);
                                    }
                                }
                            }
                        });

                        // 影響を受けたセルのみソートと時間サマリーを更新
                        affectedCells.forEach(cell => {
                            sortMagnetsInCell(cell);
                            updateCellTimeSummary(cell);
                        });

                        // 担当者の合計時間を部分更新
                        const allCells = Array.from(row.querySelectorAll('td.drop-zone:not(.storage-location)'));
                        affectedCells.forEach(affectedCell => {
                            const index = allCells.indexOf(affectedCell);
                            if (index !== -1 && staffNames[index]) {
                                updateStaffTotal(staffNames[index], index);
                            }
                        });
                    }

                    // setupDragAndDrop は初回のみ呼ばれるため、再呼び出し不要（イベント委譲化済み）
                    // updateAllHours も部分更新済みなので不要

                } catch (error) {
                    console.error('リモート更新の反映エラー:', error);
                } finally {
                    isUpdatingFromRemote = false;
                }
            }

            // リアルタイムリスナーの設定
            function setupRealtimeSync() {
                const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

                // 既存のリスナーを解除
                if (realtimeUnsubscribe) {
                    console.log('📡 既存のリアルタイムリスナーを解除');
                    realtimeUnsubscribe();
                }

                if (!db || !window.firestoreUtils || !window.firestoreUtils.onSnapshot) {
                    console.warn('⚠️ リアルタイム同期: Firebase未設定');
                    return;
                }

                const { collection, onSnapshot } = window.firestoreUtils;
                const daysCollectionRef = collection(db, MAGNET_PLACEMENTS, yearMonth, 'days');

                console.log(`📡 リアルタイム同期を開始: ${yearMonth}`);
                console.log('📡 監視パス:', `${MAGNET_PLACEMENTS}/${yearMonth}/days`);

                // 初回のスナップショットをスキップするためのフラグ
                let isFirstSnapshot = true;

                realtimeUnsubscribe = onSnapshot(daysCollectionRef, (snapshot) => {
                    // 初回のスナップショットはスキップ（既にloadMagnetPlacementsFromFirebaseで読み込み済み）
                    if (isFirstSnapshot) {
                        isFirstSnapshot = false;
                        console.log('📡 初回スナップショット受信（スキップ）');
                        return;
                    }

                    snapshot.docChanges().forEach((change) => {
                        // 自分の変更は反映しない（無限ループ防止）
                        if (isUpdatingFromRemote) return;

                        const day = change.doc.id;
                        const data = change.doc.data();

                        if (change.type === 'modified' || change.type === 'added') {
                            console.log(`🔔 変更検知: ${day}日 (タイプ: ${change.type})`);
                            updateTableFromRemote(day, data);
                        } else if (change.type === 'removed') {
                            console.log(`🗑️ 削除検知: ${day}日`);
                            // 日全体が削除された場合の処理（必要に応じて実装）
                        }
                    });
                }, (error) => {
                    console.error('リアルタイム同期エラー:', error);
                });
            }

            // 担当者リストの読み込み完了後にテーブルを描画
            renderMonthlyTable(currentDate.getFullYear(), currentDate.getMonth() + 1);

            // テーブル描画完了後にマグネット配置を読み込み
            setTimeout(async () => {
                await loadMagnetPlacementsFromFirebase(currentDate.getFullYear(), currentDate.getMonth() + 1);

                // リアルタイム同期を開始
                setupRealtimeSync();
            }, 500);

            // ========================================
            // 担当者情報機能
            // ========================================
            const staffInfoModal = document.getElementById('staff-info-modal');
            const staffInfoForm = document.getElementById('staff-info-form');
            const closeStaffInfoModalBtn = document.getElementById('close-staff-info-modal-btn');
            const cancelStaffInfoBtn = document.getElementById('cancel-staff-info-btn');

            // 担当者情報ボタンのクリックイベント（イベント委譲）
            document.addEventListener('click', (e) => {
                const staffInfoBtn = e.target.closest('.staff-info-btn');
                if (staffInfoBtn) {
                    const staffName = staffInfoBtn.dataset.staffName;
                    if (staffName) {
                        openStaffInfoModal(staffName);
                    }
                }
            });

            // 担当者情報モーダルを開く関数
            async function openStaffInfoModal(staffName) {
                console.log('🔍 担当者情報モーダルを開きます:', staffName);

                // モーダルタイトルを設定
                document.getElementById('staff-info-modal-title').textContent = `${staffName}様 - 担当者情報`;
                document.getElementById('staff-info-employee-name').value = staffName;

                // Firestoreから担当者情報を読み込む
                try {
                    // グローバルに公開されたFirebase関数を使用
                    const firebaseDB = window.firebaseDB;
                    const { collection, query, where, getDocs } = window.firestoreUtils || {};

                    if (firebaseDB && collection) {
                        console.log('🔍 Firestoreからデータを検索中... (name ==', staffName, ')');
                        const usersRef = collection(firebaseDB, 'uses');
                        const q = query(usersRef, where('name', '==', staffName));
                        const querySnapshot = await getDocs(q);

                        console.log('🔍 検索結果:', querySnapshot.size, '件のドキュメントが見つかりました');

                        let staffInfo = {};
                        if (!querySnapshot.empty) {
                            const userDoc = querySnapshot.docs[0];
                            const userData = userDoc.data();
                            console.log('🔍 取得したドキュメントID:', userDoc.id);
                            console.log('🔍 取得したデータ全体:', userData);
                            console.log('🔍 staffInfoフィールド:', userData.staffInfo);
                            staffInfo = userData.staffInfo || {};
                        } else {
                            console.warn('⚠️ 担当者が見つかりませんでした:', staffName);
                        }

                        // フォームに値を設定
                        const schedule = staffInfo.schedule || {};
                        document.getElementById('schedule-mon').value = schedule.mon || '';
                        document.getElementById('schedule-tue').value = schedule.tue || '';
                        document.getElementById('schedule-wed').value = schedule.wed || '';
                        document.getElementById('schedule-thu').value = schedule.thu || '';
                        document.getElementById('schedule-fri').value = schedule.fri || '';
                        document.getElementById('schedule-sat').value = schedule.sat || '';
                        document.getElementById('schedule-sun').value = schedule.sun || '';

                        const services = staffInfo.services || [];
                        document.getElementById('service-physical').checked = services.includes('身体介護');
                        document.getElementById('service-housework').checked = services.includes('家事援助');
                        document.getElementById('service-transport').checked = services.includes('移動支援');
                        document.getElementById('service-accompany').checked = services.includes('同行援護');

                        const transport = staffInfo.transport || [];
                        document.getElementById('transport-bike').checked = transport.includes('バイク');
                        document.getElementById('transport-car').checked = transport.includes('車');
                        document.getElementById('transport-bicycle').checked = transport.includes('自転車');

                        document.getElementById('staff-notes').value = staffInfo.notes || '';
                    } else {
                        console.error('❌ Firebaseが初期化されていません (firebaseDB:', !!window.firebaseDB, ', firestoreUtils:', !!window.firestoreUtils, ')');
                    }
                } catch (error) {
                    console.error('担当者情報の読み込みエラー:', error);
                }

                // モーダルを表示
                staffInfoModal.style.display = 'flex';
            }

            // 担当者情報フォームの送信処理
            staffInfoForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const staffName = document.getElementById('staff-info-employee-name').value;

                // フォームデータを収集
                const services = [];
                if (document.getElementById('service-physical').checked) services.push('身体介護');
                if (document.getElementById('service-housework').checked) services.push('家事援助');
                if (document.getElementById('service-transport').checked) services.push('移動支援');
                if (document.getElementById('service-accompany').checked) services.push('同行援護');

                const transport = [];
                if (document.getElementById('transport-bike').checked) transport.push('バイク');
                if (document.getElementById('transport-car').checked) transport.push('車');
                if (document.getElementById('transport-bicycle').checked) transport.push('自転車');

                const updatedStaffInfo = {
                    schedule: {
                        mon: document.getElementById('schedule-mon').value,
                        tue: document.getElementById('schedule-tue').value,
                        wed: document.getElementById('schedule-wed').value,
                        thu: document.getElementById('schedule-thu').value,
                        fri: document.getElementById('schedule-fri').value,
                        sat: document.getElementById('schedule-sat').value,
                        sun: document.getElementById('schedule-sun').value
                    },
                    services: services,
                    transport: transport,
                    notes: document.getElementById('staff-notes').value
                };

                // Firestoreに保存
                try {
                    // グローバルに公開されたFirebase関数を使用
                    const firebaseDB = window.firebaseDB;
                    const { collection, query, where, getDocs, doc, updateDoc } = window.firestoreUtils || {};

                    if (firebaseDB && collection) {
                        const usersRef = collection(firebaseDB, 'uses');
                        const q = query(usersRef, where('name', '==', staffName));
                        const querySnapshot = await getDocs(q);

                        if (!querySnapshot.empty) {
                            const userDoc = querySnapshot.docs[0];
                            const userDocRef = doc(firebaseDB, 'uses', userDoc.id);
                            await updateDoc(userDocRef, {
                                staffInfo: updatedStaffInfo
                            });
                            console.log('✅ 担当者情報を保存しました:', updatedStaffInfo);
                            alert('担当者情報を保存しました');
                            staffInfoModal.style.display = 'none';
                        } else {
                            alert('エラー: 担当者が見つかりません');
                        }
                    } else {
                        console.error('❌ Firebaseが初期化されていません (firebaseDB:', !!firebaseDB, ', firestoreUtils:', !!window.firestoreUtils, ')');
                        alert('Firebaseが初期化されていません');
                    }
                } catch (error) {
                    console.error('担当者情報の保存エラー:', error);
                    alert('担当者情報の保存中にエラーが発生しました: ' + error.message);
                }
            });

            // モーダルを閉じる
            closeStaffInfoModalBtn.addEventListener('click', () => {
                staffInfoModal.style.display = 'none';
            });

            cancelStaffInfoBtn.addEventListener('click', () => {
                staffInfoModal.style.display = 'none';
            });

            staffInfoModal.addEventListener('click', (e) => {
                if (e.target === staffInfoModal) {
                    staffInfoModal.style.display = 'none';
                }
            });

            // ========================================
            // エクスポート機能（CSV出力 / スプレッドシート転記）
            // ========================================

            // CSV出力関数
            function exportToCSV(placements, yearMonth) {
                let csv = '\uFEFF'; // BOM
                csv += '日付,曜日,担当者,利用者名,サービス内容,開始時間,終了時間,時間,備考\n';

                placements.forEach(p => {
                    const date = new Date(p.date);
                    const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][date.getDay()];
                    const timeMatch = p.time.match(/(\d{2}:\d{2})-(\d{2}:\d{2})/);
                    const startTime = timeMatch ? timeMatch[1] : '';
                    const endTime = timeMatch ? timeMatch[2] : '';

                    const escapeCSV = (field) => {
                        if (field === null || field === undefined) return '';
                        const str = String(field);
                        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                            return `"${str.replace(/"/g, '""')}"`;
                        }
                        return str;
                    };

                    csv += `${escapeCSV(p.date)},`;
                    csv += `${escapeCSV(dayOfWeek)},`;
                    csv += `${escapeCSV(p.staff)},`;
                    csv += `${escapeCSV(p.userName)},`;
                    csv += `${escapeCSV(p.serviceType)},`;
                    csv += `${escapeCSV(startTime)},`;
                    csv += `${escapeCSV(endTime)},`;
                    csv += `${escapeCSV(p.time)},`;
                    csv += `${escapeCSV(p.note || '')}\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `月間シフト_${yearMonth}.csv`;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                alert(`CSVファイルをダウンロードしました。\n${placements.length}件のデータを出力しました。`);
            }

            // スプレッドシート転記のヘルパー関数
            function timeToMinutes(timeStr) {
                if (!timeStr || typeof timeStr !== 'string') return 0;
                const [hours, minutes] = timeStr.split(':').map(Number);
                return hours * 60 + minutes;
            }

            function minutesToTime(minutes) {
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
            }

            function calculateDailyWorkHours(dayShifts) {
                if (!dayShifts || dayShifts.length === 0) {
                    return { startTime: '', endTime: '', breakTime: '' };
                }

                const services = dayShifts.filter(shift => {
                    return shift.userName && shift.userName !== '中抜け' && shift.time;
                });

                if (services.length === 0) {
                    return { startTime: '', endTime: '', breakTime: '' };
                }

                const serviceTimes = services.map(service => {
                    const timeMatch = service.time.match(/(\d{1,2}:\d{2})-(\d{1,2}:\d{2})/);
                    if (timeMatch) {
                        return {
                            start: timeMatch[1],
                            end: timeMatch[2],
                            startMinutes: timeToMinutes(timeMatch[1]),
                            endMinutes: timeToMinutes(timeMatch[2])
                        };
                    }
                    return null;
                }).filter(t => t !== null);

                if (serviceTimes.length === 0) {
                    return { startTime: '', endTime: '', breakTime: '' };
                }

                serviceTimes.sort((a, b) => a.startMinutes - b.startMinutes);

                const startTime = serviceTimes[0].start;
                const endTime = serviceTimes[serviceTimes.length - 1].end;

                let breakMinutes = 0;
                let hasBreak = false;

                for (let i = 0; i < serviceTimes.length - 1; i++) {
                    const currentEnd = serviceTimes[i].endMinutes;
                    const nextStart = serviceTimes[i + 1].startMinutes;
                    const gap = nextStart - currentEnd;

                    if (gap >= 90 && !hasBreak) {
                        breakMinutes = 60;
                        hasBreak = true;
                        break;
                    }
                }

                const breakTime = breakMinutes > 0 ? minutesToTime(breakMinutes) : '';

                return { startTime, endTime, breakTime };
            }

            async function saveToSpreadsheetsCollection(yearMonth, placements) {
                if (!window.db) {
                    throw new Error('Firebaseが初期化されていません');
                }

                console.log(`[スプレッドシート転記] ${yearMonth}のデータを処理中... (${placements.length}件のマグネット)`);

                const { doc, setDoc } = window.firestoreUtils;

                // 既存のstaffNames配列を使用（全社員リスト）
                const employees = staffNames;

                // 月の日数を取得
                const [year, month] = yearMonth.split('-').map(Number);
                const daysInMonth = new Date(year, month, 0).getDate();
                const allDays = Array.from({ length: daysInMonth }, (_, i) => String(i + 1));

                // 社員ごと・日付ごとにマグネットをグループ化
                const shiftsByStaffAndDate = {};

                // 全社員を初期化
                employees.forEach(employeeName => {
                    shiftsByStaffAndDate[employeeName] = {};
                    allDays.forEach(day => {
                        shiftsByStaffAndDate[employeeName][day] = [];
                    });
                });

                // マグネット情報を振り分け
                placements.forEach(placement => {
                    if (!placement.date || placement.staff === '未割り当て' ||
                        placement.staff === '保管場所' || placement.userName === '中抜け') {
                        return;
                    }

                    const day = placement.date.split('-')[2].replace(/^0/, '');

                    // 社員が存在する場合のみ追加
                    if (shiftsByStaffAndDate[placement.staff] && shiftsByStaffAndDate[placement.staff][day]) {
                        shiftsByStaffAndDate[placement.staff][day].push({
                            userName: placement.userName,
                            serviceType: placement.serviceType,
                            time: placement.time
                        });
                    }
                });

                // 行=社員、列=日付の形式でデータを構築
                const workHoursData = {};

                employees.forEach(employeeName => {
                    workHoursData[employeeName] = {};

                    allDays.forEach(day => {
                        const shifts = shiftsByStaffAndDate[employeeName][day] || [];
                        const workHours = calculateDailyWorkHours(shifts);
                        workHoursData[employeeName][day] = workHours;
                    });
                });

                const spreadsheetDocRef = doc(window.db, 'spreadsheets', yearMonth);
                await setDoc(spreadsheetDocRef, {
                    yearMonth,
                    employees,
                    days: allDays,
                    workHoursData,
                    updatedAt: new Date().toISOString(),
                    description: '月間勤務時間データ(行=社員、列=日付、出勤・退勤・休憩時間)'
                });

                console.log(`[スプレッドシート転記] ${yearMonth}のデータを保存しました (${employees.length}名 × ${allDays.length}日)`);
                return employees.length;
            }

            // エクスポートボタンのイベントリスナー
            const exportCSVBtn = document.getElementById('exportCSVBtn');
            if (exportCSVBtn) {
                exportCSVBtn.addEventListener('click', async () => {
                    try {
                        const placements = collectMagnetPlacements();
                        const yearMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, '0')}`;

                        if (placements.length === 0) {
                            alert('出力するデータがありません。');
                            return;
                        }

                        const choice = confirm('エクスポート方法を選択してください:\n\nOK = スプレッドシートに転記\nキャンセル = CSV出力');

                        if (choice) {
                            // スプレッドシートに転記
                            try {
                                const processedDays = await saveToSpreadsheetsCollection(yearMonth, placements);
                                alert(`${yearMonth}の勤務時間データをFirestoreに保存しました。\n処理日数: ${processedDays}日\n\nGoogle Apps Scriptから「勤務時間データを取得」を実行してください。`);
                            } catch (spreadsheetErr) {
                                console.error('スプレッドシート転記エラー:', spreadsheetErr);
                                alert('スプレッドシート転記に失敗しました: ' + spreadsheetErr.message);
                            }
                        } else {
                            // CSV出力
                            exportToCSV(placements, yearMonth);
                        }
                    } catch (err) {
                        console.error('エクスポートエラー:', err);
                        alert('エクスポートに失敗しました: ' + err.message);
                    }
                });
            }

            // ========================================
            // 支給量アラート機能
            // ========================================

            /**
             * 支給量バッジを更新
             */
            function updateLimitAlertBadge() {
                if (!fetchedUsers || fetchedUsers.length === 0) {
                    console.log('updateLimitAlertBadge: ユーザーデータなし');
                    return;
                }

                console.log('updateLimitAlertBadge: ユーザー数 =', fetchedUsers.length);
                console.log('fetchedUsers サンプル:', fetchedUsers.slice(0, 3));

                const userHours = calculateMonthlyServiceHours();
                console.log('計算された使用時間:', userHours);

                const exceeded = checkServiceLimitExceeded(fetchedUsers);
                console.log('超過者:', exceeded);

                if (exceeded.length > 0) {
                    limitAlertBadge.textContent = exceeded.length;
                    limitAlertBadge.classList.remove('hidden');
                    limitAlertBtn.classList.add('badge-active');
                    console.log('バッジ表示: ' + exceeded.length + '件');
                } else {
                    limitAlertBadge.classList.add('hidden');
                    limitAlertBtn.classList.remove('badge-active');
                    console.log('バッジ非表示: 超過なし');
                }
            }

            /**
             * 支給量アラートモーダルを表示
             */
            function showLimitAlertModal() {
                if (!fetchedUsers || fetchedUsers.length === 0) {
                    alert('利用者データが読み込まれていません');
                    return;
                }

                const exceeded = checkServiceLimitExceeded(fetchedUsers);

                // 再計算したカウントでバッジを同期
                updateLimitAlertBadge();

                // カウントを更新
                limitAlertCount.textContent = exceeded.length;

                // テーブルを更新
                if (exceeded.length === 0) {
                    limitAlertList.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 16px; color: #6c757d;">支給量を超過しているサービスはありません</td></tr>';
                } else {
                    limitAlertList.innerHTML = exceeded.map(item => {
                        const serviceDisplay = resolveServiceAbbreviation(item.serviceType, item.serviceType) || item.serviceType;
                        return `
                        <tr>
                            <td style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">${item.name}</td>
                            <td style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">${serviceDisplay}</td>
                            <td style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left;">${item.limit.toFixed(1)}h</td>
                            <td style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left; font-weight: bold; color: #dc3545;">${item.used.toFixed(1)}h</td>
                            <td style="border: 1px solid #dee2e6; padding: 4px 8px; text-align: left; font-weight: bold; color: #dc3545;">+${item.over.toFixed(1)}h</td>
                        </tr>
                    `;
                    }).join('');
                }

                // モーダルを表示
                limitAlertModal.style.display = 'flex';
            }

            // 支給量ボタンのクリックイベント
            if (limitAlertBtn) {
                limitAlertBtn.addEventListener('click', showLimitAlertModal);
            }

            // 支給量アラートモーダルのクローズ処理
            if (limitAlertModal) {
                const closeButtons = limitAlertModal.querySelectorAll('.modal-close-btn');
                closeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        limitAlertModal.style.display = 'none';
                    });
                });

                limitAlertModal.addEventListener('click', (e) => {
                    if (e.target === limitAlertModal) {
                        limitAlertModal.style.display = 'none';
                    }
                });
            }

            // 初回読み込み時に利用者データを読み込んでからバッジを更新
            console.log('🔵 支給量アラート: loadUsersFromFirebase呼び出し開始');
            loadUsersFromFirebase(() => {
                console.log('🔵 支給量アラート: loadUsersFromFirebase完了、updateLimitAlertBadge呼び出し');
                updateLimitAlertBadge();
            });

            // autoSaveMagnetPlacement関数の最後でバッジを更新（既存のautoSaveMagnetPlacement関数に以下を追加する必要あり）
            // シフトが変更されるたびにバッジを更新する仕組み
            const originalAutoSave = autoSaveMagnetPlacement;
            if (typeof originalAutoSave === 'function') {
                autoSaveMagnetPlacement = async function (changedDay) {
                    await originalAutoSave.call(this, changedDay);
                    updateLimitAlertBadge(); // バッジを更新
                };
            }

            // ========================================
            // 担当者管理モーダルのイベントハンドラー
            // ========================================
            const manageStaffBtnFromSidebar = document.getElementById('manageStaffBtn');

            // 担当者管理ボタンクリック時
            if (manageStaffBtnFromSidebar) {
                manageStaffBtnFromSidebar.addEventListener('click', () => {
                    console.log('🔧 担当者管理モーダルを開く');
                    renderStaffListEditor();
                    staffModal.classList.add('visible');
                });
            }

            // モーダル内の閉じるボタン（×ボタン）
            const staffModalCloseBtn = staffModal?.querySelector('.modal-close-btn');
            if (staffModalCloseBtn) {
                staffModalCloseBtn.addEventListener('click', () => {
                    staffModal.classList.remove('visible');
                });
            }

            // 「閉じて反映」ボタン
            if (closeStaffModalBtn) {
                closeStaffModalBtn.addEventListener('click', () => {
                    console.log('🔧 担当者管理モーダルを閉じてシフトに反映');
                    staffModal.classList.remove('visible');

                    // 現在のスクロール位置を保存
                    const tableContainer = document.getElementById('shift-table-container');
                    const savedScrollTop = tableContainer ? tableContainer.scrollTop : 0;
                    const savedScrollLeft = tableContainer ? tableContainer.scrollLeft : 0;

                    // テーブルを再描画（有効化された担当者のみ表示）
                    const year = currentDate.getFullYear();
                    const month = currentDate.getMonth() + 1;
                    renderMonthlyTable(year, month);

                    // マグネット配置を再読み込み
                    if (typeof loadMagnetsFromFirebase === 'function') {
                        loadMagnetsFromFirebase();
                    }

                    // スクロール位置を復元
                    setTimeout(() => {
                        if (tableContainer) {
                            tableContainer.scrollTop = savedScrollTop;
                            tableContainer.scrollLeft = savedScrollLeft;
                        }
                    }, 100);

                    console.log('✅ シフトテーブルを再描画しました');
                });
            }

            // モーダル背景クリックで閉じる
            if (staffModal) {
                staffModal.addEventListener('click', (e) => {
                    if (e.target === staffModal) {
                        staffModal.classList.remove('visible');
                    }
                });
            }
        });
    </script>

    <!-- メニューバーの開閉機能 -->
    <script>
        (function () {
            const menuToggle = document.getElementById('menuToggle');
            const navbarMenu = document.getElementById('navbarMenu');
            const body = document.body;

            // localStorageからメニューの表示状態を読み込み（デフォルトは非表示）
            const isMenuVisible = localStorage.getItem('menuVisible') === 'true';

            // 初期状態を設定
            if (!isMenuVisible) {
                navbarMenu.classList.add('hidden');
                body.classList.remove('menu-visible');
            } else {
                navbarMenu.classList.remove('hidden');
                body.classList.add('menu-visible');
            }

            // トグルボタンのクリックイベント
            if (menuToggle) {
                menuToggle.addEventListener('click', function () {
                    const isCurrentlyHidden = navbarMenu.classList.contains('hidden');

                    if (isCurrentlyHidden) {
                        // メニューを表示
                        navbarMenu.classList.remove('hidden');
                        body.classList.add('menu-visible');
                        localStorage.setItem('menuVisible', 'true');
                    } else {
                        // メニューを非表示
                        navbarMenu.classList.add('hidden');
                        body.classList.remove('menu-visible');
                        localStorage.setItem('menuVisible', 'false');
                    }
                });
            }

        })();
    </script>
    <!-- 権限管理スクリプト - 認証削除により無効化 -->
    <!--
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const email = localStorage.getItem('loggedInEmail');

            // 1. ログインチェック
            if (!email) {
                // ログインしていない場合はログイン画面へ
                window.location.href = '../../ログイン画面/index.html';
                return;
            }

            try {
                // Firebase初期化確認
                const db = firebase.firestore();

                // 許可メールアドレス確認
                const doc = await db.collection('allowedEmails').doc(email).get();

                if (!doc.exists) {
                    alert('ユーザー情報が見つかりません。再ログインしてください。');
                    window.location.href = '../../ログイン画面/index.html';
                    return;
                }

                const data = doc.data();

                // 2. 月間シフト自体の権限チェック
                const myPermission = data.monthlyShift || 'hidden';
                if (myPermission === 'hidden') {
                    alert('アクセス権限がありません。');
                    window.location.href = '../../ログイン画面/index.html';
                    return;
                }

                // 3. 閲覧のみ(view)の制限
                if (myPermission === 'view') {
                    // 編集系ボタンを非表示
                    const buttonsToHide = [
                        'create-magnet-btn',      // 新規作成
                        'manageStaffBtn',         // 担当者管理
                        'changeNotificationBtn',  // 変更連絡
                        'undoBtn',                // 戻る
                        'redoBtn',                // 進む
                        'saveChangesBtn'          // 保存
                    ];

                    buttonsToHide.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.display = 'none';
                    });

                    // 操作無効化（ドラッグ＆ドロップ、右クリック、ダブルクリック）
                    const stopEvent = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    };

                    // キャプチャフェーズでイベントを捕捉して停止
                    document.addEventListener('dragstart', stopEvent, true);
                    document.addEventListener('contextmenu', stopEvent, true);
                    document.addEventListener('dblclick', stopEvent, true);

                    // カーソルスタイルの変更
                    const style = document.createElement('style');
                    style.textContent = `
                        .magnet { cursor: default !important; }
                        /* ドロップゾーンのインタラクション無効化 */
                        .drop-zone { pointer-events: none; }
                    `;
                    document.head.appendChild(style);

                    // タイトルに表示追加
                    const titleEl = document.querySelector('.navbar-menu-title');
                    if (titleEl) {
                        titleEl.textContent += ' (閲覧専用)';
                    }
                }

                // 4. メニュー項目の表示制御
                const permissionMap = {
                    'shiftTodo': 'link-shiftTodo',
                    'employeeList': 'link-employeeList',
                    'userList': 'link-userList',
                    'weeklyShift': 'link-weeklyShift'
                };

                for (const [key, elementId] of Object.entries(permissionMap)) {
                    // permissionsコレクションではなく、allowedEmailsのフィールドから直接取得
                    const perm = data[key] || 'hidden';
                    const el = document.getElementById(elementId);
                    if (el && perm === 'hidden') {
                        el.style.display = 'none';
                    }
                }

            } catch (error) {
                console.error('権限チェックエラー:', error);
                // ネットワークエラー等の場合は、ユーザーの利便性を考慮してブロックしない方針とする
                // ただし本番環境ではブロックすべき
            }
        });
    </script>
    -->

    <!-- DEMO VERSION: Actual Time Mock -->
    <script>
        console.log('[DEMO] Actual Time Mock initialized');

        // モック関数 - 常に空の実績時間を返す
        function fmtHHMM(iso) {
            if (!iso) return '';
            const d = new Date(iso);
            if (isNaN(d.getTime())) return '';
            return d.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', hour12: false });
        }

        async function loadActualTimeForMagnet(magnetId) {
            console.log('[DEMO] loadActualTimeForMagnet (mock):', magnetId);
            return { startAt: '', endAt: '' };
        }

        async function updateActualTimeDisplay(magnetId) {
            const actualTimeInput = document.getElementById('actualTimeInput');
            if (!actualTimeInput) return;
            actualTimeInput.value = '';
        }

        // グローバルに公開
        window.actualTimeUtils = {
            loadActualTimeForMagnet,
            updateActualTimeDisplay,
            fmtHHMM
        };
    </script>

</body>

</html>